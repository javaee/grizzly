
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2017-06-19
 Rendered using Maven Reflow Skin 1.0.0 (http://andriusvelykis.github.com/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>Project Grizzly - FilterChains and Filters</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />
 
		<link href="//netdna.bootstrapcdn.com/bootswatch/2.2.2/cosmo/bootstrap.min.css" rel="stylesheet" />
		<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/bootswatch.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/reflow-skin.css" rel="stylesheet" />
		
		<link href="//yandex.st/highlightjs/7.3/styles/solarized_dark.min.css" rel="stylesheet" />
		
		<link href="https://javaee.github.io/grizzly//css/lightbox.css" rel="stylesheet" />
		
		<link href="https://javaee.github.io/grizzly//css/site.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/print.css" rel="stylesheet" media="print" />
		
		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->

	</head>

	<body class="page-filterchainfilters project-site" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html">Project <span class="color-brown">Grizzly</span></a>
					<div class="nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li><a href="dependencies.html" title="Download">Download </a></li>
								</ul>
							</li>
							<li class="dropdown active">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li><a href="overview.html" title="Overview">Overview </a></li>
									<li><a href="dependencies.html" title="Dependencies">Dependencies </a></li>
									<li class="dropdown-submenu">
										<a href="hack" title="Core Framework">Core Framework </a>
										<ul class="dropdown-menu">
											<li><a href="memory.html" title="Memory Management">Memory Management </a></li>
											<li><a href="iostrategies.html" title="I/O Strategies">I/O Strategies </a></li>
											<li><a href="transportsconnections.html" title="Transports and Connections">Transports and Connections </a></li>
											<li class="active"><a href="" title="FilterChain and Filters">FilterChain and Filters </a></li>
											<li><a href="coreconfig.html" title="Core configuration">Core configuration </a></li>
											<li><a href="portunification.html" title="Port Unification">Port Unification </a></li>
											<li><a href="monitoring.html" title="Monitoring">Monitoring </a></li>
											<li><a href="extras.html" title="Extras">Extras </a></li>
											<li><a href="bestpractices.html" title="Best Practices">Best Practices </a></li>
											<li><a href="quickstart.html" title="Quick Start">Quick Start </a></li>
											<li><a href="samples.html" title="Samples">Samples </a></li>
										</ul>
									</li>
									<li class="dropdown-submenu">
										<a href="hack" title="HTTP">HTTP </a>
										<ul class="dropdown-menu">
											<li><a href="httpframework.html" title="Core HTTP Framework">Core HTTP Framework </a></li>
											<li><a href="httpserverframework.html" title="HTTP Server Framework">HTTP Server Framework </a></li>
											<li><a href="http2.html" title="HTTP/2">HTTP/2 </a></li>
											<li><a href="httpserverframeworkextras.html" title="HTTP Server Framework Extras">HTTP Server Framework Extras </a></li>
											<li><a href="comet.html" title="Comet">Comet </a></li>
											<li><a href="jaxws.html" title="JAXWS">JAXWS </a></li>
											<li><a href="websockets.html" title="WebSockets">WebSockets </a></li>
											<li><a href="ajp.html" title="AJP">AJP </a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>
		
	<div class="container">
	
	<!-- Masthead
	================================================== -->
	<header class="jumbotron subhead">
		<div class="row" id="banner">
			<div class="span12">
				<div class="pull-left">
					<a href="index.html" id="bannerLeft"><h1><img src="images/grizzlyHead.png"/>&nbsp;<span class="color-black">Project</span> Grizzly</h1></a>
					<p class="lead">NIO Event Development Simplified</p>
				</div>
				<div class="pull-right">
				</div>
			</div>
		</div>
		<div>
			<ul class="breadcrumb">
				<li class="publishDate version-date">Last Published: 2017-06-19</li>
			</ul>
		</div>
		<hr class="toc-separator" />
		<div id="toc-bar" class="navbar">
			<div class="navbar-inner">
				<div id="toc-scroll-target" class="container">
					<ul id="toc" class="nav">
						<li class="toplevel"><a href="#FilterChains_and_Filters" title="FilterChains and Filters">FilterChains and Filters</a></li>
						<li class="divider-vertical"></li>
						<li class="dropdown">
							<a href="#FilterChainContext" title="FilterChainContext" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">FilterChainContext <b class="caret"></b></a>
							<ul class="dropdown-menu" role="menu">
								<!-- Repeat the item, otherwise it is not clickable as the dropdown root -->
								<li><a href="#FilterChainContext" title="FilterChainContext">FilterChainContext</a></li>
								<li class="divider"></li>
								<li><a href="#Connection" title="Connection">Connection</a></li>
								<li><a href="#Address" title="Address">Address</a></li>
								<li><a href="#Message" title="Message">Message</a></li>
								<li><a href="#Read" title="Read">Read</a></li>
								<li><a href="#Write" title="Write">Write</a></li>
								<li><a href="#Flush" title="Flush">Flush</a></li>
								<li><a href="#Event_notification" title="Event notification">Event notification</a></li>

							</ul>
						</li>
						<li class="divider-vertical"></li>
						<li class="dropdown">
							<a href="#NextAction" title="NextAction" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">NextAction <b class="caret"></b></a>
							<ul class="dropdown-menu" role="menu">
								<!-- Repeat the item, otherwise it is not clickable as the dropdown root -->
								<li><a href="#NextAction" title="NextAction">NextAction</a></li>
								<li class="divider"></li>
								<li><a href="#StopAction" title="StopAction">StopAction</a></li>
								<li><a href="#InvokeAction" title="InvokeAction">InvokeAction</a></li>
								<li><a href="#RerunFilterAction" title="RerunFilterAction">RerunFilterAction</a></li>
								<li><a href="#SuspendAction" title="SuspendAction">SuspendAction</a></li>
								<li><a href="#ForkAction_was_SuspendStopAction" title="ForkAction (was SuspendStopAction)">ForkAction (was SuspendStopAction)</a></li>

							</ul>
						</li>
					</ul>
				</div>
			</div>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="section"> 
 <div class="page-header">
  <h2 id="FilterChains_and_Filters">FilterChains and Filters</h2>
 </div> 
 <p>In the previous sections we mentioned the <i>Processor</i>, and its role - processing I/O events occurred on Grizzly *Connection*s. The <i>FilterChain</i> is the most useful type of <i>Processor</i> used in Grizzly.</p> 
 <p><img src="images/coreframework/filterchain-diagram.png" alt="&quot;&quot;" /></p> 
 <p><i>FilterChain</i>, according to its name, is a chain of *Filter*s. Each <i>Filter</i> represents a unit of processing work to be performed, whose purpose is to examine and/or modify the state of the transaction that is represented by a <i>FilterChainContext</i>.</p> 
 <p>To give an idea how <i>FilterChain</i> may look like, here is example of <i>FilterChain</i>, which implements HTTP server logic:</p> 
 <p><img src="images/coreframework/http-filterchain.png" alt="&quot;&quot;" /></p> 
 <ul> 
  <li> <p>TransportFilter is responsible to read data from network <i>Connection</i> to a <i>Buffer</i>, and to write data from <i>Buffer</i> to a nework <i>Connection</i></p></li> 
  <li> <p>HttpFilter is responsible for <i>Buffer</i> &lt;-&gt; <i>HttpPacket</i> transformation (both directions)</p></li> 
  <li> <p>HttpServerFilter is responsible for processing request *HttpPacket*s and generating response *HttpPacket*s and send them back on <i>FilterChain</i> in opposite direction (HttpServerFilter-&gt;HttpFilter-&gt;TransportFilter).</p></li> 
 </ul> 
 <p>So, what if we want to implement HTTPS server? It’s simple:</p> 
 <p><img src="images/coreframework/https-filterchain.png" alt="&quot;&quot;" /></p> 
 <p>we add just one SSLFilter, responsible for encoding/decoding SSL secured data.</p> 
 <p>As we see, during the processing of any I/O Event, Filters in a FilterChain will be executed in the certain order. <b>It’s important to remember that the most of I/O Events are processed starting from first filter to last (from left to right on the schema above), except WRITE event, whose processing starts from last Filter in chain to first (from right to left a the schema above).</b></p> 
 <p>Let’s define some <b>terminology</b> to make the following descriptions clearer:</p> 
 <ul> 
  <li> <p><b>Upstream</b> - direction from this Filter to the last Filter in chain (from left to right on the schema above);</p></li> 
  <li> <p><b>Downstream</b> - direction from this Filter to the first Filter in chain (from right to left on the schema above);</p></li> 
 </ul> 
 <p>Let’s take a look which I/O events could be processed by a <i>FilterChain</i>, for that purpose we can just take a look at the <i>Filter</i> interface methods:</p> 
 <div class="source"> 
  <pre>public NextAction handleRead(FilterChainContext ctx) throws IOException;

public NextAction handleWrite(FilterChainContext ctx) throws IOException;

public NextAction handleConnect(FilterChainContext ctx) throws IOException;

public NextAction handleAccept(FilterChainContext ctx) throws IOException;

public NextAction handleClose(FilterChainContext ctx) throws IOException;
</pre> 
 </div> 
 <p>so I/O events are</p> 
 <ul> 
  <li> <p>READ: data is available from a Connection, which could be read and processed;</p></li> 
  <li> <p>WRITE: data is going to be written to a Connection and the Filter might be responsible to transform data representation form, like <i>HttpPacket</i> -&gt; <i>Buffer</i> on schema above;</p></li> 
  <li> <p>CONNECT: new client <i>Connection</i> has been connected;</p></li> 
  <li> <p>ACCEPT (TCP only): new client <i>Connection</i> has been accepted by server <i>Connection</i> (<i>TCPNIOServerConnection</i>);</p></li> 
  <li> <p>CLOSE: the Connection has been closed (either locally or by peer);</p></li> 
 </ul> 
 <p><b>It’s important to remember that the same I/O events on the specific Connection are processed serially. For example, if we process READ I/O event on Connection “A”, Grizzly will never start processing another READ I/O event on the same Connection “A” until the processing of the previous READ I/O event has completed processing. If the user decides to take ownership of I/O event processing, then the “rule” of serial event processing should still be observed.</b></p> 
 <p>Additionally FilterChain Filters are able to initiate and handle custom event notifications. The event initiator may choose to emit the event upstream or downstream by FilterChain like:</p> 
 <div class="source"> 
  <pre>public NextAction handleRead(FilterChainContext ctx) throws IOException {
        // Here we decide to notify downstream Filters
        ctx.notifyDownstream(new OneEvent(...));

        // Notify upstream Filters
        ctx.notifyUpstream(new AnotherEvent(...));
}
</pre> 
 </div> 
 <p>The Filters in FilterChain are able to intercept and process custom Events by implementing method:</p> 
 <div class="source"> 
  <pre>public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException;
</pre> 
 </div> 
 <p>As we see each Filter “handle” method has FilterChainContext parameter and returns NextAction result.</p> 
</div> 
<div class="section"> 
 <h2 id="FilterChainContext">FilterChainContext</h2> 
 <p><img src="images/coreframework/filterchaincontext.png" alt="filter" /></p> 
 <p>FilterChainContext represents a context (state), associated with processing of specific I/O event on the specific Connection, so its lifecycle is bound to the processing of a single I/O event.</p> 
 <p>FilterChainContext contains following state information:</p> 
 <div class="section"> 
  <div class="section"> 
   <h4 id="Connection"><b>Connection</b></h4> 
   <p>The Connection I/O event occurred on;</p> 
  </div> 
  <div class="section"> 
   <h4 id="Address"><b>Address</b></h4> 
   <p>The peer address. In most cases it returns the same value as <i>Connection.getPeerAddress()</i>, except in the case when we handle a READ event on unbound UDP Connection. In this case, the <i>FilterChainContext.getAddress()</i> will return the address of peer, which sent data;</p> 
  </div> 
  <div class="section"> 
   <h4 id="Message"><b>Message</b></h4> 
   <p>The message being processed. This is the only value Filters may change during the I/O event processing. Usually it is used during the incoming/outgoing message parsing/serializing. Each Filter is able to take initial message data, transform it to a different representation, set it back and pass processing to the next Filter in chain.</p> 
   <p>For example, when handling READ event, HttpFilter gets message from FilterChainContext as Grizzly Buffer, transforms it to a HttpPacket, sets HttpPacket back to FilterChainContext message and passes control to a HttpServerFilter, which will get HttpPacket from the FilterChainContext and process it.</p> 
   <p>In addition to holding the state, the FilterChainContext provides support for commonly used I/O operations:</p> 
  </div> 
  <div class="section"> 
   <h4 id="Read"><b>Read</b></h4> 
   <p><tt>ReadResult readResult = ctx.read();</tt></p> 
   <p>This operation performs a blocking FilterChain read starting at the first Filter in chain (inclusive) upstream to this Filter (exclusive).</p> 
   <p>The operation will return a result, when processing of READ I/O event will reach the current Filter and FilterChain will be about to call handleRead(…) operation of this Filter.</p> 
  </div> 
  <div class="section"> 
   <h4 id="Write"><b>Write</b></h4> 
   <p><tt>ctx.write(message);</tt></p> 
   <p>or</p> 
   <p><tt>ctx.write(message, completionHandler);</tt></p> 
   <p>or</p> 
   <p><tt>ctx.write(address, message, completionHandler); // Unbound UDP only</tt></p> 
   <p>This operation performs a non-blocking FilterChain write starting at this Filter (exclusive) downstream to the first Filter (inclusive). This operation initiates processing of WRITE I/O event on the FilterChain starting from this Filter (exclusive).</p> 
  </div> 
  <div class="section"> 
   <h4 id="Flush"><b>Flush</b></h4> 
   <p><tt>ctx.flush();</tt></p> 
   <p>or</p> 
   <p><tt>ctx.flush(completionHandler);</tt></p> 
   <p>This operation initializes and notifies downstream filters about special <i>TransportFilter.FlushEvent</i> so each Filter is able to handle this event and make sure all the cached data was written on the Connection.</p> 
  </div> 
  <div class="section"> 
   <h4 id="Event_notification"><b>Event notification</b></h4> 
   <p><tt>ctx.notifyUpstream(event);</tt></p> 
   <p>or</p> 
   <p><tt>ctx.notifyDownstream(event);</tt></p> 
   <p>This operation notifies all the upstream/downstream Filters in the FilterChain about specific <i>FilterChainEvent</i>.</p> 
  </div> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="NextAction">NextAction</h2> 
 <p>As stated previously, during processing of an I/O Event, the FilterChain is calling Filters one by one from first to last except WRITE event, which is being processed from last Filter to first. At the same time Filters can change the default I/O Event processing order by returning different types of NextAction:</p> 
 <div class="section"> 
  <div class="section"> 
   <h4 id="StopAction"><b>StopAction</b></h4> 
   <p><tt>return ctx.getStopAction();</tt></p> 
   <p>instructs the FilterChain to stop the processing of this I/O Event. Usually StopAction is returned when there isn’t enough data to continue FilterChain processing, or it’s the last Filter in the chain.</p> 
   <p>The StopAction could be parameterized:</p> 
   <p><tt>return ctx.getStopAction(incompleteChunk);</tt></p> 
   <p>or</p> 
   <p><tt>return ctx.getStopAction(incompleteChunk, appender);</tt></p> 
   <p>An incompleteChunk in StopAction means there isn’t enough data to continue FilterChain processing. As more data becomes available but before FilterChain calls the Filter, it will check if the Filter has any data stored after the last invocation. If an incompleteChunk is present it will append the new data to the stored one and pass the result as the FilterChainContext message.</p> 
   <p>Note: the incompleteChunk should be “appendable”, so the FilterChain will know how new data chunk should be appended to the stored one. So the incompleteChunk should either implement <i>org.glassfish.grizzly.Appendable</i> or <i>org.glassfish.grizzly.Appender</i> should be passed as additional parameter.</p> 
  </div> 
  <div class="section"> 
   <h4 id="InvokeAction"><b>InvokeAction</b></h4> 
   <p><tt>return ctx.getInvokeAction();</tt></p> 
   <p>instructs the FilterChain to run next Filter in chain according to the natural execution order.</p> 
   <p>It’s possible to create the InvokeAction with an <b><i>incompleteChunk</i></b> parameter:</p> 
   <p><tt>return ctx.getInvokeAction(incompleteChunk, appender);</tt></p> 
   <p>this instructs the FilterChain to store the incompleteChunk and continue FilterChain execution like it was with non-parameterized version.</p> 
   <p>This feature is particularly useful for those cases a message or several messages are parsed from the source Buffer and discover that there is a remainder whose data is not enough to transform to an application message. So the developer can continue the FilterChain processing with the message(s) that were parsed and store the incompleteChunk remainder. As more data becomes available but before FilterChain calls the Filter again, it will check if the Filter has any data stored after the last invocation. If an incompleteChunk is present it will append the new data to the stored one and pass the result as the FilterChainContext message.</p> 
   <p>Note: the incompleteChunk should be “appendable”, so the FilterChain will know how new data chunk should be appended to the stored one. So the incompleteChunk should either implement <i>org.glassfish.grizzly.Appendable</i> or <i>org.glassfish.grizzly.Appender</i> should be passed as additional parameter.</p> 
   <p>Another option is to create the InvokeAction with an <b><i>unparsedChunk</i></b> parameter:</p> 
   <p><tt>return ctx.getInvokeAction(unparsedChunk);</tt></p> 
   <p>this instructs the FilterChain to store the unparsedChunk and continue FilterChain execution like it was with non-parameterized version. Unlike in the “incompleteChunk” case described above, this time we don’t know if unparsedChunk has enough data to transform to application message(s) or not. Once the FilterChain execution completes, the unparsedChunk of the most recent Filter in chain will be restored FilterChain processing will be re-initialed immediately starting from the Filter which stored the unparsedChunk.</p> 
   <p>This feature is particularly useful for those cases a message is parsed from the source Buffer and discover that the Buffer contains a remainder, which may or may not contain more messages. This allows the developer to extract the first message and save the remainder to be processed after the current message processing has been completed.</p> 
  </div> 
  <div class="section"> 
   <h4 id="RerunFilterAction"><b>RerunFilterAction</b></h4> 
   <p><tt>return ctx.getRerunFilterAction();</tt></p> 
   <p>Instructs the FilterChain to re-run this Filter one more time. This can useful to simplify I/O event processing code and avoid recursions.</p> 
  </div> 
  <div class="section"> 
   <h4 id="SuspendAction"><b>SuspendAction</b></h4> 
   <p><tt>return ctx.getSuspendAction();</tt></p> 
   <p>Instructs the FilterChain to terminate (leave) the I/O event processing in the current thread. The user will be able to resume the I/O event processing by calling</p> 
   <ul> 
    <li> <p><tt>ctx.resume()</tt>: resumes processing at the same Filter it was suspended.</p></li> 
    <li> <p><tt>ctx.resume(NextAction)</tt>: resumes processing at the same Filter it was suspended, but instead of passing control to the Filter - it simulates the Filter processing completion like if it returned NextAction as the result</p></li> 
    <li> <p><tt>ctx.resumeNext()</tt>: resumes processing at the Filter next to the Filter it was suspended at. Same as <tt>ctx.resume(ctx.getInvokeAction())</tt>.</p></li> 
   </ul> 
   <p>Please note, after returning SuspendAction and before I/O event processing will be resumed, Grizzly <a href="#fc-serial-rule">won’t initialize</a> the same I/O event processing on the same Connection. For example if we return the SuspendAction during READ event processing - Grizzly won’t notify the FilterChain about any new data coming on the same Connection, until READ event of the suspended event has been completed.</p> 
  </div> 
  <div class="section"> 
   <h4 id="ForkAction_was_SuspendStopAction"><b>ForkAction (was SuspendStopAction)</b></h4> 
   <p><tt>return ctx.getForkAction();</tt></p> 
   <p>This NextAction is very similar to <a href="#suspend-action">SuspendAction</a>, except for one important thing. After getting ForkAction, Grizzly will keep listening for the same I/O events on the Connection and notify FilterChain if they occur.</p> 
   <p>Special care should be taken with this NextAction to ensure that two or more threads are not processing the same I/O operation simultaneously.</p> 
  </div> 
 </div> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->
	
	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Main</li>
						<li>
							<a href="index.html" title="Home">Home </a>
						</li>
						<li>
							<a href="license.html" title="License">License </a>
						</li>
						<li>
							<a href="using.html" title="Who's Using Grizzly">Who's Using Grizzly </a>
						</li>
						<li class="nav-header">Download</li>
						<li>
							<a href="dependencies.html" title="Download">Download </a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Contribute</li>
						<li>
							<a href="contribute.html" title="Contribute">Contribute </a>
						</li>
						<li>
							<a href="http://stackoverflow.com/questions/tagged/grizzly" title="StackOverflow" class="externalLink">StackOverflow </a>
						</li>
						<li>
							<a href="https://twitter.com/project_grizzly" title="Twitter" class="externalLink">Twitter </a>
						</li>
						<li>
							<a href="mailing.html" title="Mailing Lists">Mailing Lists </a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
					</ul>
				</div>
			</div>
		</div>
	</footer>
		
	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2017. All Rights Reserved.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->

	<!-- Fallback jQuery loading from Google CDN:
	     http://stackoverflow.com/questions/1014203/best-way-to-use-googles-hosted-jquery-but-fall-back-to-my-hosted-library-on-go -->
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
	<script type="text/javascript">
		if (typeof jQuery == 'undefined')
		{
			document.write(unescape("%3Cscript src='https://javaee.github.io/grizzly//js/jquery-1.8.3.min.js' type='text/javascript'%3E%3C/script%3E"));
		}
	</script>
	
	<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/lightbox.js"></script>
	<script src="https://javaee.github.io/grizzly//js/jquery.smooth-scroll.min.js"></script>
	<!-- back button support for smooth scroll -->
	<script src="https://javaee.github.io/grizzly//js/jquery.ba-bbq.min.js"></script>
	<script src="//yandex.st/highlightjs/7.3/highlight.min.js"></script>

	<script src="https://javaee.github.io/grizzly//js/reflow-skin.js"></script>
	
	</body>
</html>
