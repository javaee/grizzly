
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2021-03-19
 Rendered using Reflow Maven Skin 1.1.1 (http://andriusvelykis.github.io/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>Project Grizzly - Http Server Framework Overview</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />
 
		<link href="//netdna.bootstrapcdn.com/bootswatch/2.3.2/cosmo/bootstrap.min.css" rel="stylesheet" />
		<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/bootswatch.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/reflow-skin.css" rel="stylesheet" />

		<link href="//yandex.st/highlightjs/7.5/styles/solarized_dark.min.css" rel="stylesheet" />

		<link href="https://javaee.github.io/grizzly//css/lightbox.css" rel="stylesheet" />

		<link href="https://javaee.github.io/grizzly//css/site.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/print.css" rel="stylesheet" media="print" />

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->



	</head>

	<body class="page-httpserverframework project-site" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#top-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html">Project <span class="color-brown">Grizzly</span></a>
					<div class="nav-collapse collapse" id="top-nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="dependencies.html" title="Download">Download</a></li>
								</ul>
							</li>
							<li class="dropdown active">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="overview.html" title="Overview">Overview</a></li>
									<li ><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
									<li class="dropdown-submenu ">
										<a href="hack" title="Core Framework">Core Framework</a>
										<ul class="dropdown-menu">
											<li ><a href="memory.html" title="Memory Management">Memory Management</a></li>
											<li ><a href="iostrategies.html" title="I/O Strategies">I/O Strategies</a></li>
											<li ><a href="transportsconnections.html" title="Transports and Connections">Transports and Connections</a></li>
											<li ><a href="filterchainfilters.html" title="FilterChain and Filters">FilterChain and Filters</a></li>
											<li ><a href="coreconfig.html" title="Core configuration">Core configuration</a></li>
											<li ><a href="portunification.html" title="Port Unification">Port Unification</a></li>
											<li ><a href="monitoring.html" title="Monitoring">Monitoring</a></li>
											<li ><a href="extras.html" title="Extras">Extras</a></li>
											<li ><a href="bestpractices.html" title="Best Practices">Best Practices</a></li>
											<li ><a href="quickstart.html" title="Quick Start">Quick Start</a></li>
											<li ><a href="samples.html" title="Samples">Samples</a></li>
										</ul>
									</li>
									<li class="dropdown-submenu ">
										<a href="hack" title="HTTP">HTTP</a>
										<ul class="dropdown-menu">
											<li ><a href="httpframework.html" title="Core HTTP Framework">Core HTTP Framework</a></li>
											<li class="active"><a href="" title="HTTP Server Framework">HTTP Server Framework</a></li>
											<li ><a href="http2.html" title="HTTP/2">HTTP/2</a></li>
											<li ><a href="httpserverframeworkextras.html" title="HTTP Server Framework Extras">HTTP Server Framework Extras</a></li>
											<li ><a href="comet.html" title="Comet">Comet</a></li>
											<li ><a href="jaxws.html" title="JAXWS">JAXWS</a></li>
											<li ><a href="websockets.html" title="WebSockets">WebSockets</a></li>
											<li ><a href="ajp.html" title="AJP">AJP</a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>

	<div class="container">

	<!-- Masthead
	================================================== -->

	<header>
	<div class="jumbotron subhead">
		<div class="row" id="banner">
			<div class="span12">
				<div class="pull-left">
					<a href="index.html" id="bannerLeft"><h1><img src="images/grizzlyHead.png"/>&nbsp;<span class="color-black">Project</span> Grizzly</h1></a>
					<p class="lead">NIO Event Development Simplified</p>
				</div>
				<div class="pull-right">
				</div>
			</div>
		</div>
	</div>
		<div>
			<ul class="breadcrumb">
				<li class="publishDate version-date">Last Published: 2021-03-19</li>
			</ul>
		</div>
		<hr class="toc-separator" />
		<div id="toc-bar" class="navbar" data-spy="affix" data-offset-top="250">
			<div class="navbar-inner">
				<div id="toc-scroll-target" class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#toc-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<div class="nav-collapse collapse" id="toc-nav-collapse">
						<ul id="toc" class="nav">
						<li class="toplevel"><a href="#Http_Server_Framework_Overview" title="Http Server Framework Overview">Http Server Framework Overview</a></li>
						<li class="divider-vertical"></li>
						<li class="dropdown">
							<a href="#Building_a_Simple_Web_Server" title="Building a Simple Web Server" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">Building a Simple Web Server <b class="caret"></b></a>
							<ul class="dropdown-menu" role="menu">
								<!-- Repeat the item, otherwise it is not clickable as the dropdown root -->
								<li><a href="#Building_a_Simple_Web_Server" title="Building a Simple Web Server">Building a Simple Web Server</a></li>
								<li class="divider"></li>
								<li><a href="#Components_of_the_Framework" title="Components of the Framework">Components of the Framework</a></li>
								<li><a href="#Quick_Start" title="Quick Start">Quick Start</a></li>

							</ul>
						</li>
						<li class="divider-vertical"></li>
						<li class="toplevel"><a href="#HTTP_Server_Configuration" title="HTTP Server Configuration">HTTP Server Configuration</a></li>
						<li class="divider-vertical"></li>
						<li class="toplevel"><a href="#Long-lasting_HTTP_requests_suspendresponse" title="Long-lasting HTTP requests (suspend/response)">Long-lasting HTTP requests (suspend/response)</a></li>
		<li class="divider-vertical"></li>
		<li class="dropdown">
			<a href="#" title="More&hellip;" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">&hellip; <b class="caret"></b></a>
			<ul class="dropdown-menu" role="menu">
								<li class="dropdown-submenu">
									<a href="#NIO_Streams" title="NIO Streams">NIO Streams</a>
									<ul class="dropdown-menu" role="menu">
								<li><a href="#Non-Blocking_Writing" title="Non-Blocking Writing">Non-Blocking Writing</a></li>
								<li><a href="#Non-Blocking_Reading" title="Non-Blocking Reading">Non-Blocking Reading</a></li>

									</ul>
								</li>
								<li><a href="#File_Cache" title="File Cache">File Cache</a></li>
								<li class="dropdown-submenu">
									<a href="#Access_Logging" title="Access Logging">Access Logging</a>
									<ul class="dropdown-menu" role="menu">
								<li><a href="#Custom_log_formats_and_appenders" title="Custom log formats and appenders.">Custom log formats and appenders.</a></li>

									</ul>
								</li>
								<li><a href="#AddOn" title="AddOn">AddOn</a></li>
								<li><a href="#Embedded_prioritization_mechanism" title="Embedded prioritization mechanism">Embedded prioritization mechanism</a></li>
								<li><a href="#Samples" title="Samples">Samples</a></li>
								<li><a href="#Other_samples" title="Other samples">Other samples</a></li>

			</ul>
		</li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="section"> 
 <div class="page-header">
  <h2 id="Http_Server_Framework_Overview">Http Server Framework Overview</h2>
 </div> 
 <p>The Grizzly HTTP server framework builds off the HTTP codec framework to provide a more useful abstraction for day-to-day work. At a high level, this framework includes the following:</p> 
 <ul> 
  <li> <p>A simple server API for easy embedding of Grizzly within an application.</p></li> 
  <li> <p>Similar abstractions to those offered by the Servlet specification: HttpHandler (Servlet), Request (HttpServletRequest), Response (HttpServletResponse).</p></li> 
  <li> <p>The ability to deal with long running HTTP transactions via response suspend/resume facilities.</p></li> 
  <li> <p>Support of non-blocking IO streams (inbound and outbound).</p></li> 
  <li> <p>A file cache for static content.</p></li> 
 </ul> 
</div> 
<div class="section"> 
 <h2 id="Building_a_Simple_Web_Server">Building a Simple Web Server</h2> 
 <div class="section"> 
  <h3 id="Components_of_the_Framework">Components of the Framework</h3> 
  <p>This section will cover the major components of this framework.</p> 
  <table border="0" class="bodyTable table table-striped table-hover"> 
   <caption>
     HTTP Server Components 
   </caption> 
   <tbody> 
    <tr class="odd"> 
     <td align="left">HttpServer</td> 
     <td align="left">This is the Grizzly HTTP server which can be used to create standalone HTTP programs or embed Grizzly within other application to provide HTTP services.</td> 
    </tr> 
    <tr class="even"> 
     <td align="left">ServerConfiguration</td> 
     <td align="left">This class allows developer to add custom HttpHandler implementations to the server as well as exposing JMX/monitoring features.</td> 
    </tr> 
    <tr class="odd"> 
     <td align="left">NetworkListener</td> 
     <td align="left">This is an abstraction of the Grizzly NIOTransport and Filter implementations. It also allows the enabling/disabling of HTTP-related features such as keep-alive, chunked transfer-encoding, cusom addons etc. HttpServer can support multiple NetworkListeners. Also, keep in mind that all HttpHandlers added to the ServerConfiguration will be shared across all listeners.</td> 
    </tr> 
    <tr class="even"> 
     <td align="left">HttpHandler</td> 
     <td align="left">HttpHandler is akin to javax.servlet.Servlet.</td> 
    </tr> 
    <tr class="odd"> 
     <td align="left">Request</td> 
     <td align="left">Request is similar to javax.servlet.http.HttpServletRequest</td> 
    </tr> 
    <tr class="even"> 
     <td align="left">Response</td> 
     <td align="left">Request is similar to javax.servlet.http.HttpServletResponse</td> 
    </tr> 
    <tr class="odd"> 
     <td align="left">Session</td> 
     <td align="left">Session is similar to javax.servlet.http.HttpSession</td> 
    </tr> 
    <tr class="even"> 
     <td align="left">HttpServerFilter</td> 
     <td align="left">This Filter implementation provides the high-level HTTP request/response processing. Note: This Filter is automatically added to the FilterChain used by the NetworkListener, but if a custom chain as well as this level of HTTP processsing, this Filter will need to be added to the chain.</td> 
    </tr> 
    <tr class="odd"> 
     <td align="left">FileCacheFilter</td> 
     <td align="left">This Filter provides static resource caching capabilities. Like the HttpServerFilter, if file caching is enabled, this Filter will be added automatically.</td> 
    </tr> 
    <tr class="even"> 
     <td align="left">AddOn</td> 
     <td align="left">The general interface for HttpServer addons, which suppose to extend basic HttpServer functionality.</td> 
    </tr> 
   </tbody> 
  </table> 
 </div> 
 <div class="section"> 
  <h3 id="Quick_Start">Quick Start</h3> 
  <p>To get started with the HTTP server framework you’ll need to include the module in your project:</p> 
  <div class="source"> 
   <pre>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.glassfish.grizzly&lt;/groupId&gt;
        &lt;artifactId&gt;grizzly-http-server&lt;/artifactId&gt;
        &lt;version&gt;2.4.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre> 
  </div> 
  <p>Once the dependencies are in place, the absolute simplest, albeit not-very-useful, server one can create is:</p> 
  <div class="source"> 
   <pre>HttpServer server = HttpServer.createSimpleServer();
try {
    server.start();
    System.out.println(&quot;Press any key to stop the server...&quot;);
    System.in.read();
} catch (Exception e) {
    System.err.println(e);
}
</pre> 
  </div> 
  <p>This will create a Grizzly HTTP server listening on 0.0.0.0:8080 and will serve content from the directory in which the JVM was started. As stated before, while this demonstrates the ease of embedding Grizzly, it’s not very useful.</p> 
  <p>Let’s add a HttpHandler to server the current time.</p> 
  <div class="source"> 
   <pre>HttpServer server = HttpServer.createSimpleServer();
server.getServerConfiguration().addHttpHandler(
    new HttpHandler() {
        public void service(Request request, Response response) throws Exception {
            final SimpleDateFormat format = new SimpleDateFormat(&quot;EEE, dd MMM yyyy HH:mm:ss zzz&quot;, Locale.US);
            final String date = format.format(new Date(System.currentTimeMillis()));
            response.setContentType(&quot;text/plain&quot;);
            response.setContentLength(date.length());
            response.getWriter().write(date);
        }
    },
    &quot;/time&quot;);
try {
    server.start();
    System.out.println(&quot;Press any key to stop the server...&quot;);
    System.in.read();
} catch (Exception e) {
    System.err.println(e);
}
</pre> 
  </div> 
  <p>Line 2 adds a new HttpHandler (think Servlet) to service requests make to /time. Any other requests to the server will be considered requests for static content served from the direction in which the JVM was started.</p> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="HTTP_Server_Configuration">HTTP Server Configuration</h2> 
 <table border="0" class="bodyTable table table-striped table-hover"> 
  <caption>
    ServerConfiguration Properties 
  </caption> 
  <tbody> 
   <tr class="odd"> 
    <td align="left">name</td> 
    <td align="left">Set the name of this HttpServer instance. If no name is defined, one will be assigned.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">jmxEnabled</td> 
    <td align="left">Determines whether or not JMX monitoring will be enabled for this HttpServer instance. This property can be changed at runtime.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">version</td> 
    <td align="left">Set the version of this server instance. If not explicitly set, the version will be 2.4.0.</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>In addition to the properties described above, the ServerConfiguration allows the addition (addHttpHandler()), removal (removeHttpHandler(), and listing of (getHttpHandlers()) HttpHandlers.</p> 
 <table border="0" class="bodyTable table table-striped table-hover"> 
  <caption>
    NetworkListener Properties 
  </caption> 
  <tbody> 
   <tr class="odd"> 
    <td align="left">name</td> 
    <td align="left">The logical name of this listener (settable only by constructor).</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">host</td> 
    <td align="left">The network host to which this listener will bind. If not user specified, it will bind to 0.0.0.0 (settable only by constructor).</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">port</td> 
    <td align="left">The network port to which this listener will bind. If not user specified, it will bind to port 8080 (settable only by constructor).</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">portRange</td> 
    <td align="left">Range of ports to attempt to bind the server to. The first port that can be bound will be used.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">keepAlive</td> 
    <td align="left">Returns the keep-alive configuration for this listener. This allows configuration for connection idle timeout (default of 30 seconds) and max keep-alive (default of 256) requests configuration.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">transport</td> 
    <td align="left">This property will typically be used for fine tuning the transport configuration, however, custom transports can also be provided.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">addons</td> 
    <td align="left">The set of addons, which suppose to extend basic HttpServer functionality.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">chunkingEnabled</td> 
    <td align="left">Enable/disable the chunk transfer-encoding (defaults to enabled).</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">secure</td> 
    <td align="left">Enable/disable SSL/TLS support (defaults to disabled)</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">sslEngineConfig</td> 
    <td align="left">If SSL/TLS is enabled, an SSLEngineConfigurator will need to be specified by the developer. This controls how the SSLEngine will be created.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">maxHttpHeaderSize</td> 
    <td align="left">Specifies, in bytes, the maximum size an http message header may be before being rejected. This configuration is only applicable to incoming requests.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">filterChain</td> 
    <td align="left">Allows customization of the FilterChain used by this listener instance.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">fileCache</td> 
    <td align="left">Allows customization of the FileCache configuration used by this listener instance.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">contentEncodings</td> 
    <td align="left">The content encodings (gzip as an example) that may be applied for HTTP transactions on this listener. Custom encodings may be provided.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">maxPendingBytes</td> 
    <td align="left">Specifies the maximum number of bytes that may be pending to be written to a particular connection. If bytes aren't being consumed and this value is exceeded, the connection will be closed.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">maxRequestHeaders</td> 
    <td align="left">Maximum number of headers allowed within a particular request. If this value is exceeded, the request will be rejected.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">maxResponseHeaders</td> 
    <td align="left">Maximum number of headers a response may send to a client. If this value is exceeded, an error will be sent to the client.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">maxPendingBytes</td> 
    <td align="left">Maximum number of bytes that may be pending to be written on a single connection. If this value is exceeded, an exception will be raised. Note that this configuration is only relevant when using non-blocking HTTP streams.</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div class="section"> 
 <h2 id="Long-lasting_HTTP_requests_suspendresponse">Long-lasting HTTP requests (suspend/response)</h2> 
 <p>Some HTTP interactions may need to trigger a long running transaction on the server and wait for the result to generate a response. However, this can be problematic with an NIO-based server as there are generally a handful of threads servicing all requests. A long running transaction in this case would tie up one of the processing threads preventing it from servicing other requests. If enough of these long running transactions were initiated, it could lead to a denial of service.</p> 
 <p>To support these use cases without negatively impacting the server, Grizzly allows a response to be suspended until such time that the long running task is complete and the response is ready to be generated.</p> 
 <p>Let’s cover the methods related to response suspend/resume. The following methods are available on the Response object itself:</p> 
 <div class="source"> 
  <pre>/**
 * Suspend the {@link Response}. Suspending a {@link Response} will
 * tell the underlying container to avoid recycling objects associated with
 * the current instance, and also to avoid committing response.
 */
public void suspend() {
    ...
}

/**
 * Suspend the {@link Response}. Suspending a {@link Response} will
 * tell the underlying container to avoid recycling objects associated with
 * the current instance, and also to avoid committing response.
 *
 * @param timeout The maximum amount of time,
 * a {@link Response} can be suspended. When the timeout expires (because
 * nothing has been written or because the {@link Response#resume()}),
 * the {@link Response} will be automatically
 * resumed and committed. Usage of any methods of a {@link Response} that
 * times out will throw an {@link IllegalStateException}.
 * @param timeunit timeout units
 *
 */
public void suspend(final long timeout, final TimeUnit timeunit) {
    ...
}

/**
 * Suspend the {@link Response}. Suspending a {@link Response} will
 * tell the underlying container to avoid recycling objects associated with
 * the current instance, and also to avoid committing response. When the
 * {@link Response#resume()} is invoked, the container will
 * make sure {@link CompletionHandler#completed(Object)}
 * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;.
 * If the timeout expires, the
 * {@link org.glassfish.grizzly.CompletionHandler#cancelled()} is invoked with
 * the original &lt;tt&gt;attachment&lt;/tt&gt; and the {@link Response} committed.
 *
 * @param timeout The maximum amount of time the {@link Response} can be suspended.
 * When the timeout expires (because nothing has been written or because the
 * {@link Response#resume()}), the {@link Response}
 * will be automatically resumed and committed. Usage of any methods of a
 * {@link Response} that times out will throw an {@link IllegalStateException}.
 * @param timeunit timeout units
 * @param completionHandler a {@link org.glassfish.grizzly.CompletionHandler}
 */
public void suspend(final long timeout,
                    final TimeUnit timeunit,
                    final CompletionHandler&lt;Response&gt; completionHandler) {
    ...
}

/**
 * Suspend the {@link Response}. Suspending a {@link Response} will
 * tell the underlying container to avoid recycling objects associated with
 * the current instance, and also to avoid committing response. When the
 * {@link Response#resume()} is invoked, the container will
 * make sure {@link CompletionHandler#completed(Object)}
 * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;.
 * If the timeout expires, the
 * {@link org.glassfish.grizzly.CompletionHandler#cancelled()} is invoked with the
 * original &lt;tt&gt;attachment&lt;/tt&gt; and the {@link Response} committed.
 *
 * @param timeout The maximum amount of time the {@link Response} can be suspended.
 * When the timeout expires (because nothing has been written or because the
 * {@link Response#resume()}), the {@link Response}
 * will be automatically resumed and committed. Usage of any methods of a
 * {@link Response} that times out will throw an {@link IllegalStateException}.
 * @param timeunit timeunit
 * @param completionHandler a {@link org.glassfish.grizzly.CompletionHandler}
 * @param timeoutHandler {@link TimeoutHandler} to customize the suspended
 *  &lt;tt&gt;Response&lt;/tt&gt; timeout logic.
 */
public void suspend(final long timeout,
                    final TimeUnit timeunit,
                    final CompletionHandler&lt;Response&gt; completionHandler,
                    final TimeoutHandler timeoutHandler) {
    ...
}

/**
 * Complete the {@link Response} and finish/commit it. If a
 * {@link CompletionHandler} has been defined, its
 * {@link CompletionHandler#completed(Object)} will first be invoked,
 * then the {@link Response#finish()}.
 * Those operations commit the response.
 */
public void resume() {
    ...
}

/**
 * Get the context of the suspended &lt;tt&gt;Response&lt;/tt&gt;.
 *
 * @return the context of the suspended &lt;tt&gt;Response&lt;/tt&gt;.
 */
public SuspendContext getSuspendContext() {
    ...
}

/**
 * Return &lt;tt&gt;true&lt;//tt&gt; if that {@link Response#suspend()} has been
 * invoked and set to &lt;tt&gt;true&lt;/tt&gt;
 * @return &lt;tt&gt;true&lt;//tt&gt; if that {@link Response#suspend()} has been
 * invoked and set to &lt;tt&gt;true&lt;/tt&gt;
 */
public boolean isSuspended() {
    ...
}
</pre> 
 </div> 
 <p>The following diagram describes a typical suspend/resume scenario:</p> 
 <p><img src="images/httpserverframework/susres.png" alt="Suspend/Resume" /></p> 
 <p>The “Suspended Response Queue” warrants some explanation. If a suspended Response has defined a timeout, it will be added to the “Suspended Response Queue”. When the queue is processed, the current time will be evaluated against the timeout as defined within the Response’s SuspendContext. If the timeout has been exceeded, the response will be committed and the Response object within the queue will be marked for removal. So in the case no timeout has been defined, the response will not be added to the queue, and the task may run indefinitely.</p> 
</div> 
<div class="section"> 
 <h2 id="NIO_Streams">NIO Streams</h2> 
 <p>In Grizzly 1.9, it was possible to write data to the client using non-blocking I/O, however, when reading post data from within a GrizzlyAdapter implementation, all I/O in that case was blocking. In Grizzly 2.3, it’s very simple using the InputStream/Reader from the request and read data in a non-blocking manner. As far as writing, all I/O will be written in non-blocking mode, but there is some extra features on the OutputStream vended by the Response instance that will be covered that expose advanced non-blocking operations.</p> 
 <div class="section"> 
  <h3 id="Non-Blocking_Writing">Non-Blocking Writing</h3> 
  <p>The methods getNIOOutputStream() and getNIOWriter() on Response return instances of NIOOutputStream and NIOWriter. In addition to the methods defined by java.io.OutputStream and java.io.Writer, these entities both implement the org.glassfish.grizzly.OutputSink interface.</p> 
  <div class="source"> 
   <pre>/**
 * &lt;p&gt;
 * This interface defines methods to allow an {@link java.io.OutputStream} or
 * {@link java.io.Writer} to allow the developer to check with the runtime
 * whether or not it's possible to write a certain amount of data, or if it's
 * not possible, to be notified when it is.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public interface OutputSink {


    /**
     * Instructs the &lt;code&gt;OutputSink&lt;/code&gt; to invoke the provided
     * {@link WriteHandler} when it is possible to write more bytes (or characters).
     *
     * Note that once the {@link WriteHandler} has been notified, it will not
     * be considered for notification again at a later point in time.
     *
     * @param handler the {@link WriteHandler} that should be notified
     *  when it's possible to write more data.
     *
     * @throws IllegalStateException if this method is invoked and a handler
     *  from a previous invocation is still present (due to not having yet been
     *  notified).
     *
     * @since 2.3
     */
    void notifyCanWrite(final WriteHandler handler);


    /**
     * @return &lt;code&gt;true&lt;/code&gt; if a write to this &lt;code&gt;OutputSink&lt;/code&gt;
     *  will succeed, otherwise returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @since 2.3
     */
    boolean canWrite();

}
</pre> 
  </div> 
  <p>The typical flow when using these methods is to call canWrite(). If the call to this method returns false, the application should call notifyCanWrite() providing a WriteHandler that will be invoked when I/O is possible.</p> 
  <p>For Grizzly 2.3 HTTP applications that deal in primarily binary data and are using Grizzly Buffers, they can leverage an additional method available on the NIOOutputStream specified by the BinaryNIOutputSink interface. This interface allows the direct writing of Buffer instances. This optimizes away the need to copy bytes to a Buffer implementation under the covers.</p> 
  <div class="source"> 
   <pre>/**
 * Adds the ability for binary based {@link NIOOutputSink}s to write a
 * {@link Buffer} instead of having to convert to those types supported by
 * {@link java.io.OutputStream}.
 *
 * @since 2.0
 */
public interface BinaryNIOOutputSink extends NIOOutputSink {

    /**
     * Writes the contents of the specified {@link org.glassfish.grizzly.Buffer}.
     *
     * @param buffer the {@link org.glassfish.grizzly.Buffer to write}
     */
    void write(final Buffer buffer) throws IOException;

}
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="Non-Blocking_Reading">Non-Blocking Reading</h3> 
  <p>On the input, side, Grizzly provides a similar interface for non-blocking reads called NIOInputSource.</p> 
  <div class="source"> 
   <pre>/**
 * &lt;p&gt;
 * This interface defines methods to allow an {@link InputStream} or
 * {@link Reader} to notify the developer &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how much&lt;/em&gt;
 * data is ready to be read without blocking.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public interface InputSource {


    /**
     * &lt;p&gt;
     * Notify the specified {@link ReadHandler} when any number of bytes
     * can be read without blocking.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Invoking this method is equivalent to calling: notifyAvailable(handler, 1).
     * &lt;/p&gt;
     *
     * @param handler the {@link ReadHandler} to notify.
     *
     * @throws IllegalArgumentException if &lt;code&gt;handler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalStateException if an attempt is made to register a handler
     *  before an existing registered handler has been invoked or if all request
     *  data has already been read.
     *
     * @see ReadHandler#onDataAvailable()
     * @see ReadHandler#onAllDataRead()
     */
    void notifyAvailable(final ReadHandler handler);


    /**
     * &lt;p&gt;
     * Notify the specified {@link ReadHandler} when the number of bytes that
     * can be read without blocking is greater or equal to the specified
     * &lt;code&gt;size&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param handler the {@link ReadHandler} to notify.
     * @param size the least number of bytes that must be available before
     *  the {@link ReadHandler} is invoked.
     *
     * @throws IllegalArgumentException if &lt;code&gt;handler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *  or if &lt;code&gt;size&lt;/code&gt; is less or equal to zero.
     * @throws IllegalStateException if an attempt is made to register a handler
     *  before an existing registered handler has been invoked or if all request
     *  data has already been read.
     *
     * @see ReadHandler#onDataAvailable()
     * @see ReadHandler#onAllDataRead()
     */
    void notifyAvailable(final ReadHandler handler, final int size);


    /**
     * @return &lt;code&gt;true&lt;/code&gt; when all data for this particular request
     *  has been read, otherwise returns &lt;code&gt;false&lt;/code&gt;.
     */
    boolean isFinished();


    /**
     * @return the number of bytes (or characters) that may be obtained
     *  without blocking.  Note when dealing with characters, this method
     *  will return an estimate on the number of characters available.
     */
    int readyData();


    /**
     * @return &lt;code&gt;true&lt;/code&gt; if data can be obtained without blocking,
     *  otherwise returns &lt;code&gt;false&lt;/code&gt;.
     */
    boolean isReady();

}
</pre> 
  </div> 
  <p>The general idea behind non-blocking writes holds true for non-blocking reads. The developer can check to see if data is available to be read without blocking by calling isReady() or checking for a non-zero return from readyData(). If no data can be read without blocking, use notifyAvailable(ReadHandler) or notifyAvailable(ReadHandler, int). When data becomes available, the ReadHandler will be invoked. Note that if no length is provided to the notifyAvailable() methods, the ReadHandler will be invoked as soon as any data becomes available. In this case, it’s a good idea to check how much can be read by another call to readyData().</p> 
  <p>For optimized reading of binary data, there is the specialized interface, BinaryNIOInputSource, that allows direct access to the Buffer used to store the incoming data:</p> 
  <div class="source"> 
   <pre>/**
 * Adds the ability for binary based {@link NIOInputSource}s to obtain the
 * incoming {@link org.glassfish.grizzly.Buffer} directly without having to
 * use intermediate objects to copy the data to.
 *
 * @since 2.0
 */
public interface BinaryNIOInputSource extends NIOInputSource {

    /**
     * &lt;p&gt;
     * Returns the underlying {@link org.glassfish.grizzly.Buffer} that backs this
     *  &lt;code&gt;NIOInputSource&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @return the underlying {@link org.glassfish.grizzly.Buffer} that backs this
     *  &lt;code&gt;NIOInputSource&lt;/code&gt;.
     */
    Buffer getBuffer();

}
</pre> 
  </div> 
  <p>One final word on InputStream, OutputStream, Reader, Writer and their NIO* counterparts returning by Request and Response objects. Since Grizzly 2.3 there are no modes (NIO or blocking) streams operate in. There are only two rules (actually one rule):</p> 
  <ul> 
   <li> <p>if InputSource.isReady() returned true - next input operation (only one) is guaranteed to be non-blocking, otherwise if InputSource.isReady() returned false or we didn’t check it - next input operation may block;</p></li> 
   <li> <p>if OutputSink.canWrite() returned true - next output operation (only one) is guaranteed to be non-blocking, otherwise if OutputSink.canWrite() returned false or we didn’t check it - next output operation may block;</p></li> 
  </ul> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="File_Cache">File Cache</h2> 
 <p>The FileCache allows for efficient caching of static content. There are several configuration options that allow fine tuning of each FileCache instance:</p> 
 <table border="0" class="bodyTable table table-striped table-hover"> 
  <caption>
    FileCache Configuration Properties 
  </caption> 
  <tbody> 
   <tr class="odd"> 
    <td align="left">secondsMaxAge</td> 
    <td align="left">Specifies how long an resource may exist within the cache. If the value is zero or less, the resource may be cached indefinately. If not specified, the value defaults to -1.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">maxCacheEntries</td> 
    <td align="left">Specified how many resources may be cached. An attempt to add an entry that causes the max number of entries to be exceeded, the resource will be removed from the cache. The default number of cached entries is 1024.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">minEntrySize</td> 
    <td align="left">The maximum size, in bytes, a file must be in order to be cached in the heap cache. This defaults to Long.MIN_VALUE.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">maxEntrySize</td> 
    <td align="left">The maximum size, in bytes, a resource may be before it can no longer be considered cacheable. This defaults to Long.MAX_VALUE.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">maxLargeFileCacheSize</td> 
    <td align="left">The maximum size, in bytes, of the memory mapped cache for large files. This defaults to Long.MAX_VALUE.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">maxSmallFileCacheSize</td> 
    <td align="left">The maximum size, in bytes, a file must be in order to be cached in the heap cache vs the mapped memory cache. This defaults to 1048576.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">enabled</td> 
    <td align="left">Whether or not the FileCache is enabled. This defaults to true on new NetworkListener instances.</td> 
   </tr> 
  </tbody> 
 </table> 
 <p>All properties of the FileCache can be manipulated by obtaining the FileCache instance by calling NetworkListener.getFileCache().</p> 
</div> 
<div class="section"> 
 <h2 id="Access_Logging">Access Logging</h2> 
 <p>Access logging is now available as of Grizzly 2.3.12. Logging is enabled via a Probe that may be registered with one or more NetworkListeners. It is recommended to use the org.glassfish.grizzly.http.httpserver.accesslog.AccessLogBuilder to create instances of the probe.</p> 
 <p>For example:</p> 
 <div class="source"> 
  <pre>final AccessLogBuilder builder = new AccessLogBuilder(&quot;/tmp/access.log&quot;);
builder.instrument(httpServer.getServerConfiguration());
</pre> 
 </div> 
 <p>The above code registers the default access logging probe globally to all listeners associated with the <tt>httpServer</tt>. However, the following configuration options are available through the builder:</p> 
 <table border="0" class="bodyTable table table-striped table-hover"> 
  <caption>
    AccessLogBuilder Configuration Properties 
  </caption> 
  <tbody> 
   <tr class="odd"> 
    <td align="left">format (either type String or AccessLogFormat (described later))</td> 
    <td align="left">Specifies the log record format. If this configuration is not explicitly set, it will default to the NCSA extended/combined log format. Additional formats are available. See the javadocs for ApacheLogFormat for details.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">timeZone (either type String or java.util.TimeZone)</td> 
    <td align="left">The time zone for the timestamped log records. If not specified, it will default to the timezone of the system running the server.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">statusThreshold (type int)</td> 
    <td align="left">Specifies the minimum HTTP status code that will trigger an entry in the access log. If not specified, then all status codes are valid.</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">rotateHourly</td> 
    <td align="left">If set, then the access logs will be rotated hourly. For example, if the file name specified was `access.log`, files will be archived on a hourly basis with names like `access-yyyyMMDDhh.log`</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">rotateDaily</td> 
    <td align="left">If set, then the access logs will be rotated daily. For example, if the file name specified was `access.log`, files will be archived on a daily basis with names like `access-yyyyMMDD.log`</td> 
   </tr> 
   <tr class="even"> 
    <td align="left">rotatePattern (type String)</td> 
    <td align="left">Specifies a java.util.SimpleDateFormat pattern for automatic log file rotation. For example, if the file name specified was `access.log` and the `rotation pattern` specified was `EEE` (day name in week), files will be archived on a daily basis with names like `access-Mon.log`, `access-Tue.log`, etc.</td> 
   </tr> 
   <tr class="odd"> 
    <td align="left">synchronous (type boolean)</td> 
    <td align="left">Specifies whether access log entries should be written `synchronously` or not. If not specified, logging will occur asynchronously.</td> 
   </tr> 
  </tbody> 
 </table> 
 <div class="section"> 
  <h3 id="Custom_log_formats_and_appenders">Custom log formats and appenders.</h3> 
  <p>Log recorder formatting and appending is accomplished by the AccessLogFormat and AccessLogAppender interfaces.</p> 
  <div class="source"> 
   <pre>package org.glassfish.grizzly.http.server.accesslog;

...

/**
 * An interface defining a component capable of formatting {@link Response}s
 * into printable &lt;em&gt;access log entries&lt;/em&gt;.
 *
 * &lt;p&gt;Implementations of this class &lt;b&gt;must&lt;/b&gt; be thread-safe.&lt;/p&gt;
 */
public interface AccessLogFormat {

    /**
     * Format the data contained in the specified {@link Response} and return
     * a {@link String} which can be appended to an access log file.
     *
     * @param response The {@link Response} holding the data to format.
     * @param timeStamp The {@link Date} at which the request was originated.
     * @param responseNanos The time, in nanoseconds, the {@link Response}
     *                      took to complete.
     */
    String format(Response response, Date timeStamp, long responseNanos);

}
</pre> 
  </div> 
  <div class="source"> 
   <pre>package org.glassfish.grizzly.http.server.accesslog;

...

/**
 * An interface defining an &lt;em&gt;appender&lt;/em&gt; for Grizzly access logs entries.
 */
public interface AccessLogAppender extends Closeable {

    /**
     * Append the specified access log entry.
     *
     * @param accessLogEntry The {@link String} value of the data to be append
     *                       in the access log.
     * @throws IOException If an I/O error occurred appending to the log.
     */
    void append(String accessLogEntry)
    throws IOException;

    /**
     * Close any underlying resource owned by this appender.
     */
    @Override
    void close()
    throws IOException;
}
</pre> 
  </div> 
  <p>Grizzly’’s implementation, as hinted by the builder documentation above, does come with defaults for both interfaces.</p> 
  <p>The default <tt>AccessLogFormatter</tt> is the <tt>ApacheLogFormatter</tt>. This implementation provides the same functionality as the <tt>mod_log_config</tt> (<a class="externalLink" href="http://httpd.apache.org/docs/2.2/mod/mod_log_config.html">http://httpd.apache.org/docs/2.2/mod/mod_log_config.html</a>). Custom formats may be created using the format Strings as specified by <tt>mod_log_config</tt>. The <tt>ApacheLogFormatter</tt> also defines several default format Strings that may be used - see the javadocs for details.</p> 
  <p>As far as <tt>AccessLogAppender</tt>s, the following are included:</p> 
  <ul> 
   <li> <p>FileAppender (standard log file writing)</p></li> 
   <li> <p>QueueingAppender (asyncronous log file writing)</p></li> 
   <li> <p>RotatingFileAppender (automatic log file rotation)</p></li> 
   <li> <p>StreamAppender (appends to the provided java.io.OutputStream)</p></li> 
  </ul> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="AddOn">AddOn</h2> 
 <p>The AddOn abstraction provides a simple and generic way how to extend existing HttpServer functionality. The interface looks very simple:</p> 
 <div class="source"> 
  <pre>/**
 * The {@link HttpServer} addon interface, responsible for adding
 * features like WebSockets, Comet to HttpServer.
 */
public interface AddOn {
    /**
     * The method, which will be invoked by {@link HttpServer} in order to
     * initialize the AddOn on the passed {@link NetworkListener}.
     * Most of the time the AddOn implementation will update the passed
     * {@link NetworkListener}'s {@link FilterChainBuilder} by adding custom
     * {@link Filter}(s), which implement AddOn's logic.
     *
     * @param networkListener the {@link NetworkListener} the addon is being
     *          initialized on.
     * @param builder the {@link FilterChainBuilder},
     *          representing the {@link NetworkListener} logic.
     */
    public void setup(NetworkListener networkListener,
            FilterChainBuilder builder);
}
</pre> 
 </div> 
 <p>So basically custom AddOn should implement only one method, and most of the time AddOn just inserts a custom logic Filter into the given FilterChainBuilder. Here is example of WebSocketAddOn:</p> 
 <div class="source"> 
  <pre>/**
 * WebSockets {@link AddOn} for the {@link org.glassfish.grizzly.http.server.HttpServer}.
 */
public class WebSocketAddOn implements AddOn {

    @Override
    public void setup(final NetworkListener networkListener,
            final FilterChainBuilder builder) {

        // Get the index of HttpCodecFilter in the HttpServer filter chain
        final int httpCodecFilterIdx = builder.indexOfType(HttpCodecFilter.class);

        if (httpCodecFilterIdx &gt;= 0) {
            // Insert the WebSocketFilter right after HttpCodecFilter
            builder.add(httpCodecFilterIdx + 1, new WebSocketFilter());
        }
    }
}
</pre> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Embedded_prioritization_mechanism">Embedded prioritization mechanism</h2> 
 <p>Starting with version 2.3, Grizzly provides embedded support for prioritizing incoming HTTP requests processing implemented on a container level</p> 
 <p>In some cases it may have certain advantages comparing to application level prioritization mechanism provided by HttpResponse’s suspend/resume methods.</p> 
 <p>Every time before invoking HttpHandler.service(Request, Response) method, Grizzly HTTP server asks HttpHandler which thread-pool it wants to be used:</p> 
 <div class="source"> 
  <pre>public class MyHttpHandler extends HttpHandler {
    ...................................

    /**
     * Returns the &lt;tt&gt;HttpHandler&lt;/tt&gt; preferred {@link ExecutorService} to process
     * passed {@link Request}. The &lt;tt&gt;null&lt;/tt&gt; return value means process in
     * current thread.
     *
     * The default implementation returns &lt;tt&gt;null&lt;/tt&gt; if current thread is not
     * {@link Transport} service thread ({@link Threads#isService()}). Otherwise
     * returns worker thread pool of the {@link Transport} this {@link Request}
     * belongs to ({@link org.glassfish.grizzly.Transport#getWorkerThreadPool()}).
     *
     * @param request the {@link Request} to be processed.
     * @return the &lt;tt&gt;HttpHandler&lt;/tt&gt; preferred {@link ExecutorService} to process
     * passed {@link Request}. The &lt;tt&gt;null&lt;/tt&gt; return value means process in
     * current thread.
     */
    @Override
    protected ExecutorService getThreadPool(final Request request) {
        // return ExecutorService to process this Request
    }
}
</pre> 
 </div> 
 <p>Unlike HttpResponse’s suspend/resume mechanism this approach doesn’t impact Request/Response state and is completely transparent for application level.</p> 
 <p>Note: by default Grizzly configures HttpServer to use <a href="#iostrategies">SameThread IO strategy</a>, but at the same time initializes worker thread-pool to be used by HttpHandlers by default. In case all HttpHandlers (applications) use only custom thread pools controlled by developer’s application - it might be a good idea to prevent Grizzly creating the default worker thread-pool by calling:</p> 
 <div class="source"> 
  <pre>networkListener.getTransport().setWorkerThreadPoolConfig(null);
</pre> 
 </div> 
 <p>For more details please see the priorities sample in Grizzly http-server-framework <a href="#httpserverframework-other-samples">samples</a>.</p> 
</div> 
<div class="section"> 
 <h2 id="Samples">Samples</h2> 
 <p>The following example is a composite showing both the suspend/resume as well as the NIO streams. First we’ll show the server side. Note that the following code snippets are part of a single example that makes use nested classes.</p> 
 <div class="source"> 
  <pre>/**
 * This handler using non-blocking streams to read POST data and echo it
 * back to the client.
 */
private static class NonBlockingEchoHandler extends HttpHandler {


    // -------------------------------------------- Methods from HttpHandler


    @Override
    public void service(final Request request,
                        final Response response) throws Exception {

        final char[] buf = new char[128];
        final NIOReader in = request.getNIOReader(); // return the non-blocking InputStream
        final NIOWriter out = response.getNIOWriter();

        response.suspend();

        // If we don't have more data to read - onAllDataRead() will be called
        in.notifyAvailable(new ReadHandler() {

            @Override
            public void onDataAvailable() throws Exception {
                System.out.printf(&quot;[onDataAvailable] echoing %d bytes\n&quot;, in.readyData());
                echoAvailableData(in, out, buf);
                in.notifyAvailable(this);
            }

            @Override
            public void onError(Throwable t) {
                System.out.println(&quot;[onError]&quot; + t);
                response.resume();
            }

            @Override
            public void onAllDataRead() throws Exception {
                System.out.printf(&quot;[onAllDataRead] length: %d\n&quot;, in.readyData());
                try {
                    echoAvailableData(in, out, buf);
                } finally {
                    try {
                        in.close();
                    } catch (IOException ignored) {
                    }

                    try {
                        out.close();
                    } catch (IOException ignored) {
                    }

                    response.resume();
                }
            }
        });

    }

    private void echoAvailableData(NIOReader in, NIOWriter out, char[] buf)
            throws IOException {

        while(in.isReady()) {
            int len = in.read(buf);
            out.write(buf, 0, len);
        }
    }

} // END NonBlockingEchoHandler
</pre> 
 </div> 
 <p>As can be gleaned from the name of the class, this HttpHandler implementation simply echoes POST data back to the client.</p> 
 <p>Let’s cover the major points of this part of the example:</p> 
 <ul> 
  <li> <p>Getting NIOReader and NIOWriter to be able to leverage NIO features.</p></li> 
  <li> <p>The Response is suspended; the service() method will exit. ReadHandler implementation will be notified as data becomes available.</p></li> 
  <li> <p>The ReadHandler’s onDataAvailable callback invoked as data is received by the server and echoed back to the client.</p></li> 
  <li> <p>The ReadHandler’s onAllDataRead callback invoked when client has finished message. Any remaining data is echoed back to the client and the response is resumed.</p></li> 
 </ul> 
 <p>Now we need to create a server and install this HttpHandler:</p> 
 <div class="source"> 
  <pre>public static void main(String[] args) {

    // create a basic server that listens on port 8080.
    final HttpServer server = HttpServer.createSimpleServer();

    final ServerConfiguration config = server.getServerConfiguration();

    // Map the path, /echo, to the NonBlockingEchoHandler
    config.addHttpHandler(new NonBlockingEchoHandler(), &quot;/echo&quot;);

    try {
        server.start();
        Client client = new Client();
        client.run();
    } catch (IOException ioe) {
        LOGGER.log(Level.SEVERE, ioe.toString(), ioe);
    } finally {
        server.shutdownNow();
    }
}
</pre> 
 </div> 
 <p>This part of the example is pretty straight forward. Create the server, install the HttpHandler to service requests made to /echo, and start the server.</p> 
 <p>The client code which will follow will be sending data slowly to exercise the non-blocking HttpHandler. The client code relies on the http module primitives, so there’s a little more code here to get this part of the example going. Let’s start with the client Filter that sends request.</p> 
 <div class="source"> 
  <pre>private static final class ClientFilter extends BaseFilter {

            private static final String[] CONTENT = {
                &quot;contentA-&quot;,
                &quot;contentB-&quot;,
                &quot;contentC-&quot;,
                &quot;contentD&quot;
            };

            private FutureImpl&lt;String&gt; future;

            private StringBuilder sb = new StringBuilder();

            // ---------------------------------------------------- Constructors


            private ClientFilter(FutureImpl&lt;String&gt; future) {
                this.future = future;
            }


            // ----------------------------------------- Methods from BaseFilter


            @SuppressWarnings({&quot;unchecked&quot;})
            @Override
            public NextAction handleConnect(FilterChainContext ctx) throws IOException {
                System.out.println(&quot;\nClient connected!\n&quot;);

                HttpRequestPacket request = createRequest();
                System.out.println(&quot;Writing request:\n&quot;);
                System.out.println(request.toString());
                ctx.write(request); // write the request

                // for each of the content parts in CONTENT, wrap in a Buffer,
                // create the HttpContent to wrap the buffer and write the
                // content.
                MemoryManager mm = ctx.getConnection().getTransport().getMemoryManager();
                for (int i = 0, len = CONTENT.length; i &lt; len; i++) {
                    HttpContent.Builder contentBuilder = request.httpContentBuilder();
                    Buffer b = Buffers.wrap(mm, CONTENT[i]);
                    contentBuilder.content(b);
                    HttpContent content = contentBuilder.build();
                    System.out.printf(&quot;(Client writing: %s)\n&quot;, b.toStringContent());
                    ctx.write(content);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                // since the request created by createRequest() is chunked,
                // we need to write the trailer to signify the end of the
                // POST data
                ctx.write(request.httpTrailerBuilder().build());

                System.out.println(&quot;\n&quot;);

                return ctx.getStopAction(); // discontinue filter chain execution

            }


            @Override
            public NextAction handleRead(FilterChainContext ctx) throws IOException {

                HttpContent c = (HttpContent) ctx.getMessage();
                Buffer b = c.getContent();
                if (b.hasRemaining()) {
                    sb.append(b.toStringContent());
                }

                // Last content from the server, set the future result so
                // the client can display the result and gracefully exit.
                if (c.isLast()) {
                    future.result(sb.toString());
                }
                return ctx.getStopAction(); // discontinue filter chain execution

            }


            // ------------------------------------------------- Private Methods


            private HttpRequestPacket createRequest() {

                HttpRequestPacket.Builder builder = HttpRequestPacket.builder();
                builder.method(&quot;POST&quot;);
                builder.protocol(&quot;HTTP/1.1&quot;);
                builder.uri(&quot;/echo&quot;);
                builder.chunked(true);
                HttpRequestPacket packet = builder.build();
                packet.addHeader(Header.Host, HOST + ':' + PORT);
                return packet;

            }

        }

    } // END Client
</pre> 
 </div> 
 <p>High level points about this code:</p> 
 <ul> 
  <li> <p>When the connection is established with the server, the handleConnect() method of this Filter will be invoked. When this happens, we create a HttpRequestPacket, which contains only message part of a POST request. wThe request is then written.</p></li> 
  <li> <p>The message of the body of the message in 2 second intervals.</p></li> 
  <li> <p>When all data has been written, write the trailer to signify the end of the request since the chunked transfer encoding is being used.</p></li> 
  <li> <p>Read the response from the server. Store the final result in a future to be retrieved later.</p></li> 
 </ul> 
 <p>Lastly we need to define a client that utilizes the Filter that was just described:</p> 
 <div class="source"> 
  <pre>private static final class Client {

    private static final String HOST = &quot;localhost&quot;;
    private static final int PORT = 8080;

    public void run() throws IOException {
        final FutureImpl&lt;String&gt; completeFuture = SafeFutureImpl.create();

        // Build HTTP client filter chain
        FilterChainBuilder clientFilterChainBuilder = FilterChainBuilder.stateless();
        // Add transport filter
        clientFilterChainBuilder.add(new TransportFilter());

        // Add HttpClientFilter, which transforms Buffer &lt;-&gt; HttpContent
        clientFilterChainBuilder.add(new HttpClientFilter());
        // Add ClientFilter
        clientFilterChainBuilder.add(new ClientFilter(completeFuture));


        // Initialize Transport
        final TCPNIOTransport transport =
               TCPNIOTransportBuilder.newInstance().build();
        // Set filterchain as a Transport Processor
        transport.setProcessor(clientFilterChainBuilder.build());

        try {
            // start the transport
            transport.start();

            Connection connection = null;

            // Connecting to a remote Web server
            Future&lt;Connection&gt; connectFuture = transport.connect(HOST, PORT);
            try {
                // Wait until the client connect operation will be completed
                // Once connection has been established, the POST will
                // be sent to the server.
                connection = connectFuture.get(10, TimeUnit.SECONDS);

                // Wait no longer than 30 seconds for the response from the
                // server to be complete.
                String result = completeFuture.get(30, TimeUnit.SECONDS);

                // Display the echoed content
                System.out.println(&quot;\nEchoed POST Data: &quot; + result + '\n');
            } catch (Exception e) {
                if (connection == null) {
                    LOGGER.log(Level.WARNING, &quot;Connection failed.  Server is not listening.&quot;);
                } else {
                    LOGGER.log(Level.WARNING, &quot;Unexpected error communicating with the server.&quot;);
                }
            } finally {
                // Close the client connection
                if (connection != null) {
                    connection.close();
                }
            }
        } finally {
            // stop the transport
            transport.shutdownNow();
        }
    }
</pre> 
 </div> 
 <p>The comments within the Client code should be sufficient to explain what’s going on here. When running the complete example the output will look something like:</p> 
 <div class="source"> 
  <pre>Sep 22, 2011 3:22:58 PM org.glassfish.grizzly.http.server.NetworkListener start
INFO: Started listener bound to [0.0.0.0:8080]
Sep 22, 2011 3:22:58 PM org.glassfish.grizzly.http.server.HttpServer start
INFO: [HttpServer] Started.

Client connected!

Writing request:

HttpRequestPacket (
   method=POST
   url=/echo
   query=null
   protocol=HTTP/1.1
   content-length=-1
   headers=\[
      Host=localhost:8080]
)
(Client writing: contentA-)
[onDataAvailable] echoing 9 bytes

(delay 2 seconds)

(Client writing: contentB-)
[onDataAvailable] echoing 9 bytes

(delay 2 seconds)

(Client writing: contentC-)
[onDataAvailable] echoing 9 bytes

(delay 2 seconds)

(Client writing: contentD)
[onDataAvailable] echoing 8 bytes


[onAllDataRead] length: 0

Echoed POST Data: contentA-contentB-contentC-contentD

Sep 22, 2011 3:23:06 PM org.glassfish.grizzly.http.server.NetworkListener stop
INFO: Stopped listener bound to \[0.0.0.0:8080]
</pre> 
 </div> 
 <p>A quick note about the output above, the (delay 2 seconds) isn’t actually output. It’s been added to visualize the artificial delay added by the Filter used by the client.</p> 
 <p>This example in its entirety is available within the samples section of the Grizzly 2.4.0 repository.</p> 
</div> 
<div class="section"> 
 <h2 id="Other_samples">Other samples</h2> 
 <p>The HTTP server framework samples can be reviewed in one of two ways:</p> 
 <ul> 
  <li>Directly from the git repository:</li> 
 </ul> 
 <div class="source"> 
  <pre>git clone https://github.com/eclipse-ee4j/grizzly.git
cd grizzly
git checkout initial-contribution
cd samples/http-server-samples
</pre> 
 </div> 
 <ul> 
  <li>Download the sample source bundle from: <a class="externalLink" href="https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/samples/grizzly-http-server-samples/2.4.0/grizzly-http-server-samples-2.4.0-sources.jar">https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/samples/grizzly-http-server-samples/2.4.0/grizzly-http-server-samples-2.4.0-sources.jar</a></li> 
 </ul> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->

	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Main</li>
						<li >
							<a href="index.html" title="Home">Home</a>
						</li>
						<li >
							<a href="license.html" title="License">License</a>
						</li>
						<li >
							<a href="using.html" title="Who's Using Grizzly">Who's Using Grizzly</a>
						</li>
						<li class="nav-header">Download</li>
						<li >
							<a href="dependencies.html" title="Download">Download</a>
						</li>
					</ul>
				</div>
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Contribute</li>
						<li >
							<a href="contribute.html" title="Contribute">Contribute</a>
						</li>
						<li >
							<a href="http://stackoverflow.com/questions/tagged/grizzly" title="StackOverflow" class="externalLink">StackOverflow</a>
						</li>
						<li >
							<a href="mailing.html" title="Mailing Lists">Mailing Lists</a>
						</li>
					</ul>
				</div>
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
					</ul>
				</div>
				<div class="span0 bottom-description">
					<blockquote><div id="archive-footer" style="left: 0px;">This project is now part of the <a href="https://projects.eclipse.org/projects/ee4j">Jakarta EE Working Group</a> and has been transferred to the Eclipse Foundation.<br/>Please visit <a href="https://projects.eclipse.org/projects/ee4j.grizzly">Eclipse Grizzly</a> for all the latest developments (or the new <a href="https://github.com/eclipse-ee4j/grizzly">GitHub Repo</a>).
		</div>
						<p>
                        <a href="http://www.jetbrains.com/idea/" style="position: relative;display:block; width:120px; height:30px; border:0; margin:0;padding:0;text-decoration:none;text-indent:0;"><span style="margin: 0;padding: 0;position: absolute;top: -1px;left: 29px;font-size: 9px;cursor:pointer;  background-image:none;border:0;color: #acc4f9; font-family: trebuchet ms,arial,sans-serif;font-weight: normal;text-align:left;"></span><img src="images/logo-text.png" alt="The best Java IDE" border="0"/></a>
                        </p></blockquote>
				</div>
			</div>
		</div>
	</footer>

	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2013-2021. All Rights Reserved.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

	<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/lightbox.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/reflow-scroll.js"></script>
	<script src="//yandex.st/highlightjs/7.5/highlight.min.js"></script>

	<script src="https://javaee.github.io/grizzly//js/reflow-skin.js"></script>

	</body>
</html>
