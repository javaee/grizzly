<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011-2012 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<section version="5.0" xml:id="bestpractices"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>Best Practices</title>

  <para>When developing a network application, we usually wonder how we can
  optimize it. How should the worker thread pool be sized? Which I/O strategy
  to employ?</para>

  <para>There is no general answer for that question, but we'll try to provide
  some tips.<itemizedlist>
      <listitem>
        <para><emphasis role="bold">IOStrategy</emphasis></para>

        <para>In the <link linkend="iostrategies">IOStrategy</link> section,
        we introduced different Grizzly IOStrategies.</para>

        <para>By default, Grizzly Transports use the worker-thread IOStrategy,
        which is reliable for any possible usecase. However, if the
        application processing logic doesn't involve any blocking I/O
        operations, the same-thread IOStrategy can be used. For these cases,
        the same-thread strategy will be more performant as there are no
        thread context switches.</para>

        <para>For example, if we implement general HTTP Servlet container, we
        can't be sure about nature of specific Servlets developers may have.
        In this case it's safter to use the worker-thread IOStrategy. However,
        if application uses the Grizzly's HttpServer and HttpHandler, which
        leverages NIO streams, then the same-thread strategy could be used to
        optimize processing time and resource consumption;</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Selector runners count</emphasis></para>

        <para>The Grizzly runtime will automatically set the SelectorRunner
        count value equal to <link
        xlink:href="http://download.oracle.com/javase/6/docs/api/java/lang/Runtime.html#availableProcessors()">Runtime.getRuntime().availableProcessors()</link>.
        Depending on usecase, developers may change this value to better suit
        their needs.</para>

        <para>Scott Oaks, from the Glassfish performance team, <link
        xlink:href="http://weblogs.java.net/blog/2007/12/03/glassfish-tuning-primer">suggests</link>
        that there should be one SelectorRunner <citation>for every 1-4 cores
        on your machine; no more than that</citation>;</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Worker thread pool</emphasis></para>

        <para>In the <link linkend="threadpool-config">Configuration</link>
        section, the different thread pool implementations, and their pros and
        cons, were discussed.</para>

        <para>All IOStrategies, except the same-thread IOStrategy, use worker
        threads to process IOEvents which occur on Connections. A common
        question is how many worker threads will be needed by an
        application?</para>

        <para>In his <link
        xlink:href="http://weblogs.java.net/blog/2007/12/03/glassfish-tuning-primer">blog</link>,
        Scott suggests <citation>How many is "just enough"? It depends, of
        course -- in a case where HTTP requests don't use any external
        resource and are hence CPU bound, you want only as many HTTP request
        processing threads as you have CPUs on the machine. But if the HTTP
        request makes a database call (even indirectly, like by using a JPA
        entity), the request will block while waiting for the database, and
        you could profitably run another thread. So this takes some trial and
        error, but start with the same number of threads as you have CPU and
        increase them until you no longer see an improvement in
        throughput</citation>.</para>

        <para>Translating this to the general, non HTTP usecase: If IOEvent
        processing includes blocking I/O operation(s), which will make thread
        block doing nothing for some time (i.e, waiting for a result from a
        peer), it's best to have more worker threads to not starve other
        request processing. For simpler application processes, the fewer
        threads, the better.</para>
      </listitem>
    </itemizedlist></para>
</section>
