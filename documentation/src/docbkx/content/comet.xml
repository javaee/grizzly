<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter version="5.0" xml:id="comet"
			xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Comet</title>

  <section>
    <title>Introduction</title>

    <para>From the wikipedia page:</para>

    <para>Comet is an umbrella term used to describe a
    technique allowing web browser to receive almost real time updates from
    the server. The two most common approaches are long polling and streaming.
    Long polling differs from streaming in that each update from the server
    ultimately results in another follow up request from the server. With
    streaming, there is one long lived request serving multiple updates. The
    following sections will cover each option with samples of how to implement
    each approach.</para>

    <section>
      <title>Long Polling</title>

      <para>With long polling an initial request is made to the server. This request is "parked"
        waiting for an update. This sleeping request is then awakened when an event is called on the
        CometHandler for the request. CometHandler is an interface in the Grizzly framework which an
        application developer implements to register a suspended request with the comet system and
        manage event and lifecyle issues. CometHandler is typically where your application logic for
        your comet-based applications lives. The following example shows how to set up a long
        polling request and notify it about events. This code is taken from the count-clicker comet
        sample in the grizzly source repository
        (http://java.net/projects/grizzly/sources/git/show/samples/comet/comet-counter).</para>
      <db:programlisting>public class CounterHandler extends DefaultCometHandler&lt;HttpServletResponse> {

    private HttpServletResponse httpResponse;
    private AtomicInteger counter;

    CounterHandler(HttpServletResponse httpResponse, final AtomicInteger counter) {
        this.httpResponse = httpResponse;
        this.counter = counter;
    }

    public void onEvent(CometEvent event) throws IOException {
        if (CometEvent.Type.NOTIFY == event.getType()) {
            httpResponse.addHeader("X-JSON", "{\"counter\":" + counter.get() + " }");

            PrintWriter writer = httpResponse.getWriter();
            writer.write("success");
            writer.flush();

            event.getCometContext().resumeCometHandler(this);
        }
    }

    public void onInterrupt(CometEvent event) throws IOException {
        httpResponse.addHeader("X-JSON", "{\"counter\":" + counter.get() + " }");

        PrintWriter writer = httpResponse.getWriter();
        writer.write("success");
        writer.flush();
    }
}
</db:programlisting>
      <para>This is the CometHandler for our simple counter application.  In this simple case, it
        has an AtomicInteger for tracking count requests and return the incremented value for each
        event.  This handler is registered in a servlet as shown below.</para>
      <db:programlisting>public class LongPollingServlet extends HttpServlet {


    final AtomicInteger counter = new AtomicInteger();
    private static final long serialVersionUID = 1L;
    
    private String contextPath = null;
    
    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);

        ServletContext context = config.getServletContext();
        contextPath = context.getContextPath() + "/long_polling";
        
        CometEngine engine = CometEngine.getEngine();
        CometContext cometContext = engine.register(contextPath);
        cometContext.setExpirationDelay(5 * 30 * 1000);
    }
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res)
    throws ServletException, IOException {
        CometEngine engine = CometEngine.getEngine();
        CometContext&lt;HttpServletResponse> context = engine.getCometContext(contextPath);
        final int hash = context.addCometHandler(new CounterHandler(res, counter));
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res)
    throws ServletException, IOException {
        counter.incrementAndGet();
        CometContext&lt;HttpServletResponse> context = CometEngine.getEngine().getCometContext(contextPath);
        context.notify(null);
        
        PrintWriter writer = res.getWriter();
        writer.write("success");
        writer.flush();
    }
}</db:programlisting>
      <db:para>The first request comes into doGet() which will create the CometHandler and add it to
        the CometContext.  CometContext.addHandler() will suspend this request.  In the html for the
        application, there's a link which executes a POST against the server which calls doPost().
        Here, what we're doing is notifying the entire context of an event.  This will cause
        onEvent() to be called for each registered CometHandler.  That, as we've seen, will return
        the counter value to the browser.  After this event is processed, the suspended requests
        will be resumed and eventually terminated normally.  On the client side, once that GET
        request is terminated, the javascript in the page will submit yet another GET request.  This
        request is suspended again as describe above and the process can repeat indefinitely.  The
        javascript needed for this is shown below:</db:para>
      <db:programlisting>var counter = {
      'poll' : function() {
         new Ajax.Request('long_polling', {
            method : 'GET',
            onSuccess : counter.update
         });
      },
      'increment' : function() {
         new Ajax.Request('long_polling', {
            method : 'POST'
         });
      },
      'update' : function(req, json) {
         $('count').innerHTML = json.counter;
         counter.poll();
      }
}
</db:programlisting>
      <db:para>There are three basic functions involved in this application:  poll, increment, and update.<orderedlist>
          <listitem>
            <para>poll:  This function makes the GET requests to the server which are ultimately
              suspended.  On a successful return from that call, update() is called...</para>
          </listitem>
          <listitem>
            <para>update: This where the page is updated with the results from the server.  This
              function takes the json object returned from the servlet and updates the display
              accordingly.  The last thing it does is call back to poll() which initiates another
              suspended request.</para>
          </listitem>
          <listitem>
            <para>increment: This function is called whenever you click the link in the application.
              It initiates the POST request that causes the server state to change and results in
              the client side updates.  There is no handling of the response from this
              request.</para>
          </listitem>
        </orderedlist></db:para>
      <db:para>That's all it takes for a simple long polling based application.  Long polling
        applications are well suited for handling low frequency events from the server such as
        updates to pages in response to user actions.  Because of the need for renegotiation of
        subsequent requests after each event, applications with high event frequency are best served
        by streaming applications as we'll see below.  Long polling, however, is more proxy friendly
        in many cases.  Many proxies balk at seeing long-lived connections and might close them
        according to various security or connection timeout policies.</db:para>
    </section>
        <section>
            <db:title>Streaming</db:title>
            <db:para/>
        </section>
  </section>
</chapter>
