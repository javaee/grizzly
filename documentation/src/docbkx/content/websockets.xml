<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>WebSockets</title>

  <section xml:id="ws-whatis">
    <title>What is WebSockets?</title>

    <para>Quoting the description from <link
    xlink:href="http://tools.ietf.org/html/rfc6455">RFC 6455</link>:</para>

    <blockquote>
      <para>The WebSocket Protocol is designed to supersede existing
      bidirectional communication technologies that use HTTP as a transport
      layer to benefit from existing infrastructure (proxies, filtering,
      authentication). Such technologies were implemented as trade-offs
      between efficiency and reliability because HTTP was not initially meant
      to be used for bidirectional communication (see [RFC6202] for further
      discussion). The WebSocket Protocol attempts to address the goals of
      existing bidirectional HTTP technologies in the context of the existing
      HTTP infrastructure; as such, it is designed to work over HTTP ports 80
      and 443 as well as to support HTTP proxies and intermediaries, even if
      this implies some complexity specific to the current environment.</para>
    </blockquote>

    <para>For futher details on the protocol itself, the RFC referenced
    previously is your best source of information.</para>
  </section>

  <section xml:id="ws-overview">
    <title>Overview of Grizzly's WebSocket Implementation</title>

    <para>Grizzly 2 implements the requirements of RFC 6455, however we do
    include support for older versions of the protocol. This is particularly
    useful for clients that haven't caught up with the final draft of the
    specification. That said, please consider the support for the older
    versions to be deprecated in favor of pushing support for the final draft.
    The protocol versions supported at the time of writing are: 6, 7, 8, and
    13 (13 being the protocol version of the final draft). We do not support
    00/-76, so this may cause an issue with clients such as Safari which are
    still using this old version of the protocol.</para>

    <para>Like other protocols implemented with Grizzly 2.x, WebSocket support
    is implemented using a Filter. If you're not familiar with the concepts of
    Filters and FilterChains, please review the documentation in this guide.</para>

  </section>

  <section>
    <title xml:id="ws-api">The Grizzly WebSocket API</title>

    <para>Understanding how to use the WebSocket API is very simple as there
    are only a few core entities that developers need to be familiar with. We'll
    begin by covering those first. Once the basics are understood, creating
    websocket applications should be straight forward.</para>

    <section xml:id="ws-api-ws">
      <title>WebSocket</title>

      <para>This interface provides the core functionality needed by
      developers to both send data to a remote end-point or handle events
      triggered by the remote end-point sending data. This interface is
      relevant for both server and client side uses cases.</para>

      <programlisting language="java">public interface WebSocket {
    

    /**
     * &lt;p&gt;
     * Send a text frame to the remote end-point.
     * &lt;p&gt;
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; send(String data);

    /**
     * &lt;p&gt;
     * Send a binary frame to the remote end-point.
     * &lt;/p&gt;
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; send(byte[] data);

    /**
     * &lt;p&gt;
     * Sends a &lt;code&gt;ping&lt;/code&gt; frame with the specified payload (if any).
     * &lt;/p&gt;
     *
     * @param data optional payload.  Note that payload length is restricted
     *  to 125 bytes or less.
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     *
     * @since 2.1.9
     */
    GrizzlyFuture&lt;DataFrame&gt; sendPing(byte[] data);

    /**
     * &lt;p&gt;
     * Sends a &lt;code&gt;ping&lt;/code&gt; frame with the specified payload (if any).
     * &lt;/p&gt;
     *
     * &lt;p&gt;It may seem odd to send a pong frame, however, RFC-6455 states:&lt;/p&gt;
     *
     * &lt;p&gt;
     *     "A Pong frame MAY be sent unsolicited.  This serves as a
     *     unidirectional heartbeat.  A response to an unsolicited Pong frame is
     *     not expected."
     * &lt;/p&gt;
     *
     * @param data optional payload.  Note that payload length is restricted
     *  to 125 bytes or less.
     *             
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     *
     * @since 2.1.9
     */
    GrizzlyFuture&lt;DataFrame&gt; sendPong(byte[] data);

    /**
     * &lt;p&gt;
     * Sends a fragment of a complete message.
     * &lt;/p&gt;
     * 
     * @param last boolean indicating if this message fragment is the last.
     * @param fragment the textual fragment to send.
     *                 
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; stream(boolean last, String fragment);

    /**
     * &lt;p&gt;
     * Sends a fragment of a complete message.
     * &lt;/p&gt;
     *
     * @param last boolean indicating if this message fragment is the last.
     * @param fragment the binary fragment to send.
     * @param off the offset within the fragment to send.
     * @param len the number of bytes of the fragment to send.
     *            
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; stream(boolean last, byte[] fragment, int off, int len);

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket}.
     * &lt;/p&gt;
     */
    void close();

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket} using the specified status code.
     * &lt;/p&gt;
     *
     * @param code the closing status code.
     */
    void close(int code);

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket} using the specified status code and
     * reason.
     * &lt;/p&gt;
     *
     * @param code the closing status code.
     * @param reason the reason, if any.
     */
    void close(int code, String reason);

    /**
     * &lt;p&gt;
     * Convenience method to determine if this {@link WebSocket} is connected.
     * &lt;/p&gt;
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if the {@link WebSocket} is connected, otherwise
     *  &lt;code&gt;false&lt;/code&gt;
     */
    boolean isConnected();

    /**
     * &lt;p&gt;
     * This callback will be invoked when the opening handshake between both
     * endpoints has been completed.
     * &lt;/p&gt;
     */
    void onConnect();

    /**
     * &lt;p&gt;
     * This callback will be invoked when a text message has been received.
     * &lt;/p&gt;
     *
     * @param text the text received from the remote end-point.
     */
    void onMessage(String text);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a binary message has been received.
     * &lt;/p&gt;
     *
     * @param data the binary data received from the remote end-point.
     */
    void onMessage(byte[] data);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a fragmented textual message has
     * been received.
     * &lt;/p&gt;
     *
     * @param last flag indicating whether or not the payload received is the
     *  final fragment of a message.
     * @param payload the text received from the remote end-point.
     */
    void onFragment(boolean last, String payload);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a fragmented binary message has
     * been received.
     * &lt;/p&gt;
     *
     * @param last flag indicating whether or not the payload received is the
     *  final fragment of a message.
     * @param payload the binary data received from the remote end-point.
     */
    void onFragment(boolean last, byte[] payload);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point sent a closing 
     * frame.
     * &lt;/p&gt;
     * 
     * @param frame the close frame from the remote end-point.
     *              
     * @see DataFrame             
     */
    void onClose(DataFrame frame);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point has sent a ping
     * frame.
     * &lt;/p&gt;
     *
     * @param frame the ping frame from the remote end-point.
     * 
     * @see DataFrame             
     */
    void onPing(DataFrame frame);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point has sent a pong
     * frame.
     * &lt;/p&gt;
     *
     * @param frame the pong frame from the remote end-point.
     * 
     * @see DataFrame
     */
    void onPong(DataFrame frame);

    /**
     * Adds a {@link WebSocketListener} to be notified of events of interest.
     * 
     * @param listener the {@link WebSocketListener} to add.
     *                 
     * @return &lt;code&gt;true&lt;/code&gt; if the listener was added, otherwise 
     *  &lt;code&gt;false&lt;/code&gt;
     *  
     * @see WebSocketListener
     */
    boolean add(WebSocketListener listener);

    /**
     * Removes the specified {@link WebSocketListener} as a target of event 
     * notification.
     *
     * @param listener the {@link WebSocketListener} to remote.
     *                 
     * @return &lt;code&gt;true&lt;/code&gt; if the listener was removed, otherwise
     *  &lt;code&gt;false&lt;/code&gt;
     *         
     * @see WebSocketListener
     */
    boolean remove(WebSocketListener listener);

}</programlisting>
    </section>

    <section xml:id="ws-api-listener">
      <title>WebSocketListener</title>

      <para>Implementations of this interface allow the developers to listen
      for events occurring on various WebSocket instances. This interface is
      relevant for both server and client side uses cases.</para>

      <programlisting>/**
 * Interface to allow notification of events occurring on specific
 * {@link WebSocket} instances.
 */
public interface WebSocketListener {

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onClose(DataFrame)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;p&gt;
     *     
     * @param socket the {@link WebSocket} being closed.
     * @param frame the closing {@link DataFrame} sent by the remote end-point. 
     */
    void onClose(WebSocket socket, DataFrame frame);

    /**
     * &lt;p&gt;
     * Invoked when the opening handshake has been completed for a specific
     * {@link WebSocket} instance.
     * &lt;/p&gt;
     * 
     * @param socket the newly connected {@link WebSocket}
     */
    void onConnect(WebSocket socket);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onMessage(String)} has been called on a 
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     * 
     * @param socket the {@link WebSocket} that received a message.
     * @param text the message received.
     */
    void onMessage(WebSocket socket, String text);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onMessage(String)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received a message.
     * @param bytes the message received.
     */
    void onMessage(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onPing(DataFrame)} has been called on a 
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     * 
     * @param socket the {@link WebSocket} that received the ping.
     * @param bytes the payload of the ping frame, if any.
     */
    void onPing(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onPong(DataFrame)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received the pong.
     * @param bytes  the payload of the pong frame, if any.
     */
    void onPong(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onFragment(boolean, String)} has been called
     * on a particular {@link WebSocket} instance.
     * &lt;/p&gt;
     * 
     * @param socket the {@link WebSocket} received the message fragment.
     * @param fragment the message fragment.
     * @param last flag indicating if this was the last fragment.
     */
    void onFragment(WebSocket socket, String fragment, boolean last);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onFragment(boolean, byte[])} has been called
     * on a particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket   the {@link WebSocket} received the message fragment.
     * @param fragment the message fragment.
     * @param last     flag indicating if this was the last fragment.
     */
    void onFragment(WebSocket socket, byte[] fragment, boolean last);

}</programlisting>
    </section>

    <section xml:id="ws-api-app">
      <title>WebSocketApplication</title>

      <para>The WebSocketApplication abstract class provides the basics for
      creating a server-side WebSocket application. </para>

      <programlisting>   /**
     * Factory method to create new {@link WebSocket} instances.  Developers may
     * wish to override this to return customized {@link WebSocket} implementations.
     * 
     * @param handler the {@link ProtocolHandler} to use with the newly created
     *  {@link WebSocket}.
     *                
     * @param listeners the {@link WebSocketListener}s to associate with the new
     *   {@link WebSocket}.
     *                  
     * @return a new {@link WebSocket} instance.
     */
    public WebSocket createSocket(ProtocolHandler handler, WebSocketListener... listeners) {
        ...
    }

    /**
     * When a {@link WebSocket#onClose(DataFrame)} is invoked, the {@link WebSocket}
     * will be unassociated with this application and closed.
     * 
     * @param socket the {@link WebSocket} being closed.
     * @param frame the closing frame.
     */
    @Override
    public void onClose(WebSocket socket, DataFrame frame) {
        ...
    }

    /**
     * When a new {@link WebSocket} connection is made to this application, the
     * {@link WebSocket} will be associated with this application.  
     * 
     * @param socket the new {@link WebSocket} connection.
     */
    @Override
    public void onConnect(WebSocket socket) {
        ...
    }

    /**
     * Checks protocol specific information can and should be upgraded.
     * 
     * The default implementation will check for the precence of the 
     * &lt;code&gt;Upgrade&lt;/code&gt; header with a value of &lt;code&gt;WebSocket&lt;/code&gt;.
     * If present, {@link #isApplicationRequest(org.glassfish.grizzly.http.HttpRequestPacket)}
     * will be invoked to determine if the request is a valid websocket request.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the request should be upgraded to a 
     *  WebSocket connection
     */
    public final boolean upgrade(HttpRequestPacket request) {
        ...
    }

    /**
     * Checks application specific criteria to determine if this application can 
     * process the request as a WebSocket connection.
     *
     * @param request the incoming HTTP request.
     *                
     * @return &lt;code&gt;true&lt;/code&gt; if this application can service this request
     */
    public abstract boolean isApplicationRequest(HttpRequestPacket request);
</programlisting>

      <para>So to create a simple server-side WebSocket application, the
      developer, at a minimum, would extend this class and provide an
      implementation of isApplicationRequest(HttpRequestPacket). Most
      implementations of this method will most likely key off the request URI
      to determine if the connection should be upgraded or not. Additional
      functionality can be added as required for the application - keep in
      mind that the WebSocketApplication is, itself, a WebSocketListener which
      will be added to each WebSocket registered with it. This allows handling
      all of the events exposed by WebSocketListener (as previously
      discussed). A word of caution - if overriding
      WebSocketApplication{onConnect,onClosed} be sure to make a call to the
      super() so that the WebSocket is properly associated/unassociated with
      the application to prevent leaks.</para>
    </section>

    <section xml:id="ws-api-engine">
      <title>WebSocketEngine</title>

      <para>The final piece of the API developers should understand is the
      WebSocketEngine. The WebSocketEngine is a JVM singleton in which all
      WebSocketApplications are registered. The methods of interest here are
      register/unregister:</para>

      <programlisting>    /**
     * Registers the specified {@link WebSocketApplication} with the 
     * &lt;code&gt;WebSocketEngine&lt;/code&gt;.
     * 
     * @param app the {@link WebSocketApplication} to register.
     */
    public void register(WebSocketApplication app) {
        applications.add(app);
    }

    /**
     * Un-registers the specified {@link WebSocketApplication} with the
     * &lt;code&gt;WebSocketEngine&lt;/code&gt;.
     *
     * @param app the {@link WebSocketApplication} to un-register.
     */
    public void unregister(WebSocketApplication app) {
        applications.remove(app);
    }

    /**
     * Un-registers all {@link WebSocketApplication} instances with the 
     * {@link WebSocketEngine}.
     */
    public void unregisterAll() {
        applications.clear();
    }</programlisting>

      <para>Registration may occur at any time. For example, if this
      application is created/registered by a Servlet, then registration would
      happen in the Servlet.init() method and deregistration may happen within
      the Servlet.destroy() method. Regardless, the WebSocketApplication must
      be registered with the WebSocketEngine in order to be queried as part of
      the connection upgrade process.</para>
    </section>
  </section>

  <section xml:id="ws-server">
    <title>Using Grizzly 2 WebSockets on the Server-Side</title>

    <para>In the previous sections we touched briefly how the WebSocket
    protocol is implemented and the basic API. We'll now show the basics for
    creating a WebSocket aware server and registering the WebSocketApplication
    with the WebSocket runtime.</para>

    <para>In this example, we'll be using Grizzly standalone (of course!). So
    first, we'll create the HttpServer and enable WebSocket support.</para>

    <programlisting>final HttpServer server = HttpServer.createSimpleServer("/var/www", 8080);
final WebSocketAddOn addon = new WebSocketAddOn();
for (NetworkListener listener : server.getListeners()) {
    listener.registerAddOn(addon);
}</programlisting>

    <para>That's all there is to it! Note, that you don't need to register the
    addon for all listeners, only those listeners that you want WebSocket
    support. </para>

    <para>Next, we instantiate a WebSocketApplication implementation (we don't
    go into the details of the implementation itself - that comes later) and
    register it with the WebSocket runtime.</para>

    <programlisting>final WebSocketApplication chatApplication = new ChatApplication();
WebSocketEngine.getEngine().register(chatApplication);</programlisting>

    <para>Again, simple! Once the server is started, it will be ready to
    service WebSocket requests. </para>

    <para>For a more concrete (and runnable) example, review this simple <link
    xlink:href="http://java.net/projects/grizzly/sources/git/show/samples/websockets/chat?rev=afc47689a5c16663bc6a574e1ee2962d349cda2e">WebSocket
    Chat</link> application.</para>
  </section>

  <section xml:id="ws-client">
    <title>Grizzly WebSockets Client</title>

    <para>The Grizzly project does have a WebSocket client if such
    functionality is needed. Instead of repeating what has already been
    written, we'll recommend that you read the following <link
    xlink:href="http://www.notshabby.net/2012/01/async-http-client-1-7-0-released-details-on-the-grizzly-side-of-things/">blog
    entry</link>.</para>
  </section>
</chapter>
