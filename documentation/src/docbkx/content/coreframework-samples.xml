<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011-2013 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<section version="5.0" xml:id="coreframework-samples"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>Samples</title>

  <section xml:id="parsing-incoming">
    <title>Parsing an incoming message</title>

    <para>When writing network application, very often we need to parse
    incoming bytes into application specific message.</para>

    <para>The problem is that chunk of data been read from NIO Connection may
    contain just a part of application message, or contain several of them at
    once. So how parsing Filter should work out these scenarious?<itemizedlist>
        <listitem>
          <para>If we don't have enough data to build an application message -
          we stop the FilterChain processing and store the incomplete buffer
          by returning<programlisting language="java">return filterChainContext.getStopAction(buffer);</programlisting></para>
        </listitem>

        <listitem>
          <para>If the source Buffer contains more than one message at once -
          we're splitting up the source Buffer into two chunks:<orderedlist>
              <listitem>
                <para>The Buffer, which belongs to the first complete
                application message;</para>
              </listitem>

              <listitem>
                <para>The remainder.</para>
              </listitem>
            </orderedlist></para>

          <para>The 1st chunk could be parsed immediately and correspondent
          application message created. After completing the parsing we may
          want to instruct FilterChain to continue execution, by calling the
          next Filter in the chain, and store the remainder to be processed
          later (once processing of this message is complete).<programlisting
          language="java">return filterChainContext.getInvokeAction(remainder);</programlisting></para>
        </listitem>
      </itemizedlist></para>

    <para>Here is an example of parsing Filter, parses the incoming Buffer and
    creates a GIOPMessage, which has following structure<programlisting
    language="java">public class GIOPMessage {
    private byte G;
    private byte I;
    private byte O;
    private byte P;

    private byte major;
    private byte minor;

    private byte flags;
    private byte value;

    private int bodyLength;

    private byte[] body;
}</programlisting></para>

    <para>So the actual parser Filter code is<programlisting language="java">    private static final int HEADER_SIZE = 12;

    /**
     * Method is called, when new data was read from the Connection and ready
     * to be processed.
     *
     * We override this method to perform Buffer -&gt; GIOPMessage transformation.
     * 
     * @param ctx Context of {@link FilterChainContext} processing
     * @return the next action
     * @throws java.io.IOException
     */
    @Override
    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
        // Get the source buffer from the context
        final Buffer sourceBuffer = ctx.getMessage();

        final int sourceBufferLength = sourceBuffer.remaining();

        // If source buffer doesn't contain header
        if (sourceBufferLength &lt; HEADER_SIZE) {
            // stop the filterchain processing and store sourceBuffer to be
            // used next time
            <emphasis role="bold">return ctx.getStopAction(sourceBuffer);</emphasis>
        }

        // Get the body length
        final int bodyLength = sourceBuffer.getInt(HEADER_SIZE - 4);
        // The complete message length
        final int completeMessageLength = HEADER_SIZE + bodyLength;
        
        // If the source message doesn't contain entire body
        if (sourceBufferLength &lt; completeMessageLength) {
            // stop the filterchain processing and store sourceBuffer to be
            // used next time
            <emphasis role="bold">return ctx.getStopAction(sourceBuffer);</emphasis>
        }

        // Check if the source buffer has more than 1 complete GIOP message
        // If yes - split up the first message and the remainder
        final Buffer remainder = sourceBufferLength &gt; completeMessageLength ? 
            sourceBuffer.split(completeMessageLength) : null;

        // Construct a GIOP message
        final GIOPMessage giopMessage = new GIOPMessage();

        // Set GIOP header bytes
        giopMessage.setGIOPHeader(sourceBuffer.get(), sourceBuffer.get(),
                sourceBuffer.get(), sourceBuffer.get());

        // Set major version
        giopMessage.setMajor(sourceBuffer.get());

        // Set minor version
        giopMessage.setMinor(sourceBuffer.get());

        // Set flags
        giopMessage.setFlags(sourceBuffer.get());

        // Set value
        giopMessage.setValue(sourceBuffer.get());

        // Set body length
        giopMessage.setBodyLength(sourceBuffer.getInt());

        // Read body
        final byte[] body = new byte[bodyLength];
        sourceBuffer.get(body);
        // Set body
        giopMessage.setBody(body);

        ctx.setMessage(giopMessage);

        // We can try to dispose the buffer
        sourceBuffer.tryDispose();

        // Instruct FilterChain to store the remainder (if any) and continue execution
        <emphasis role="bold">return ctx.getInvokeAction(remainder);</emphasis>
    }</programlisting></para>
  </section>

  <section xml:id="async-filterchain-execution">
    <title>Asynchronous FilterChain execution</title>

    <para>During the FilterChain execution, we might want to continue IOEvent
    processing in the different/custom thread.</para>

    <para>For example, we've chosen the SameThreadStrategy for our usecase to
    avoid redundant thread context switches and it fits great to our usecase,
    but at the same time we still have some scenarious, which either execute
    long lasting tasks, or use blocking I/O (for ex. database access), and to
    not make entire server unresponsive, we'd want to execute such a task in
    our custom thread pool and let Grizzly service other Connections.</para>

    <para>This might be easily implemented with Grizzly using code like (not working
      sample):<programlisting language="java">    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
    
            // Get the SuspendAction in advance, cause once we execute LongLastTask in the
            // custom thread - we lose control over the context
            final NextAction suspendAction = ctx.getSuspendAction();
            
            // suspend the current execution
            ctx.suspend();
            
            // schedule async work
            scheduler.schedule(new Runnable() {

                @Override
                public void run() {
                    doLongLastingTask();

                    // Resume the FilterChain IOEvent processing
                    ctx.resumeNext();
                }
            }, 5, TimeUnit.SECONDS);

            // return suspend status
            return suspendAction;
    }</programlisting></para>

    <para>during processing IOEvent. We have to understand that by instructing Grizzly to suspend
      the IOEvent execution, we're becoming responsible for resuming the execution at one point of
      time (when long lasting task or blocking I/O operation
      completes).<programlisting language="java">public void run() {
    doLongLastingTask();

    // Resume the FilterChain IOEvent processing
    ctx.resumeNext();
}</programlisting></para>
  </section>

  <section xml:id="other-samples">
    <title>Other samples</title>

    <para>The core framwork samples can be reviewed in one of two ways:</para>

    <itemizedlist>
      <listitem>
        <para>Directly from the git repository:</para>

        <screen>git clone git://java.net/grizzly~git
cd grizzly~git
git checkout 2_3
cd samples/frameworksamples</screen>
      </listitem>

      <listitem>
        <para>Download the sample source bundle from: <link
        xlink:href="https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/samples/grizzly-framework-samples/@project.version@/grizzly-framework-samples-@project.version@-sources.jar">https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/samples/grizzly-framework-samples/@project.version@/grizzly-framework-samples-@project.version@-sources.jar</link></para>
      </listitem>
    </itemizedlist>
  </section>
</section>
