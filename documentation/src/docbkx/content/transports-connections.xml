<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<section xml:id="transcon" version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>Transports and Connections</title>

  <para>Transport and Connection represent the core network API in Grizzly
  2.0.</para>

  <para>Transport defines a network transport such as TCP or UDP, including
  associated resources (thread-pool, memory manager etc) and default
  configuration for nested Connections.</para>

  <para>Connection in Grizzly 2.0 represents a single network connection (very
  similar to socket), depending on type of Transport it could be TCP or UDP
  connection or any custom connection type.</para>

  <para>The relationship between Transport and Connection is 1-to-many.</para>

  <para><itemizedlist>
      <listitem>
        <para>Transports</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/transport-diagram.png"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>Per class diagram above, Grizzly 2.0 has two Transport
        implementations: NIO TCP and NIO UDP, which is based on Java NIO,
        though in the future, support for NIO.2 based transports and SCTP will
        be added once JDK 7 is available.</para>

        <para>Let's briefly go throw the auxiliary components mentioned on the
        diagram<itemizedlist>
            <listitem>
              <para>MemoryManager implements the memory allocation/release
              logic (see the <link linkend="memory">Memory managment</link>
              section);</para>
            </listitem>

            <listitem>
              <para>ExecutorService represents the Transport associated
              thread-pool</para>
            </listitem>

            <listitem>
              <para>Processor transport default Processor logic, which is
              responsible for processing NIO events. Processors are assigned
              per Connection, so this one will be taken as the default one,
              but each Connection may have own customized Processor</para>
            </listitem>

            <listitem>
              <para>Strategy implements IOStrategy (see <link
              linkend="iostrategies">I/O Strategies</link> section)</para>
            </listitem>

            <listitem>
              <para>NIOChannelDistributor is responsible for distributing
              newly created Connections among Transport NIO Selector
              threads</para>
            </listitem>

            <listitem>
              <para>SelectorRunner implements single Selector thread logic,
              which selects ready NIO events and passes them to the Processor,
              which will process it according to the Strategy logic</para>
            </listitem>

            <listitem>
              <para>SelectionKeyHandler is a wrapper over SelectionKey
              operations, also<itemizedlist>
                  <listitem>
                    <para>maps Java NIO operations (OP_READ, OP_WRITE etc)
                    mapping to Grizzly IOEvent</para>
                  </listitem>

                  <listitem>
                    <para>maps Java NIO SelectionKey to Grizzly
                    Connection</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>SelectorHandler implements thread-safe logic for
              registering/deregistering SelectableChannels on Selectors,
              changing SelectionKey interests, executing custom tasks in
              Selector threads (to avoid unexpected locks)</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para>Connections</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/connection-diagram.png"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>On the diagram above we see how Connections are related to
        Transports and basic Connection abstractions. In Grizzly 2.0 we have
        TCP and UDP Connection realization, besides that we have special
        server-Connections for both TCP and UDP.<itemizedlist>
            <listitem>
              <para>TCPNIOServerConnection works in a similar way as TCP
              ServerSocket. It is bound to a specific TCP host:port and
              listens for the incoming client side TCP connections. When a new
              TCP connection is ready to be accepted, TCPNIOServerConnection
              accepts it and, taking into account Transport settings, it
              configures new connection accordingly.</para>
            </listitem>

            <listitem>
              <para>UDPNIOServerConnection represents a UDP connection, which
              is not bound to any specific peer address, so it's able to
              receive all the UDP packets targeted to its UDP host:port. In
              other words the only difference between UDPNIOConnection and
              UDPNIOServerConnection is that the later is not bound to any
              peer address.</para>
            </listitem>
          </itemizedlist></para>

        <para>Let's briefly describe the rest of the components on the diagram
        above:<itemizedlist>
            <listitem>
              <para>Processor. The logic, which is responsible for processing
              Connection NIO events (ACCEPT, CONNECT, READ, WRITE,
              CLOSE)</para>
            </listitem>

            <listitem>
              <para>SelectionKey. The Connection underyling
              java.nio.channels.SelectionKey, which defines the NIO
              SelectableChannel &lt;-&gt; Selector registration.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para>Establishing client connections</para>

        <para>The ConnectorHandler API is reponsible for establishing and
        initializing client connections.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/connectorhandler-diagram.png"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>As we see from the diagram above, TCPNIOTransport and
        UDPNIOTransport implement the SocketConnectorHandler interface, so
        it's possible to create a new client Connection using the Transport
        instance directly like:<programlisting language="java">Future&lt;Connection&gt; clientConnectionFuture = tcpNioTransport.connect("grizzly.java.net", 80);
Connection clientConnection = clientConnectionFuture.get();</programlisting></para>

        <para>In this case, newly created client Connections will derive
        Transport's Processor. It's also possible to create customized
        ConnectorHandler (similar for UDP and TCP transports)
        like:<programlisting language="java">SocketConnectorHandler customUdpConnectorHandler = UDPNIOConnectorHandler.builder(udpNioTransport)
                             .processor(customFilterChain)
                             .build();
Future&lt;Connection&gt; clientConnectionFuture = customUdpConnectorHandler.connect("timeserver.com", 3333);
Connection clientConnection = clientConnectionFuture.get();</programlisting></para>

        <para>We can describe the asynchronous connect operation as two
        sequence diagrams.</para>

        <para>The first one shows the steps passed in the current thread,
        where we call <emphasis
        role="italic">ConnectorHandler.connect(...)</emphasis> operation and
        get <emphasis role="italic">Future&lt;Connection&gt;</emphasis> as the
        result:</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/connectorhandler-seq1.png"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>So the above code just adds the connection object on the
        <emphasis role="italic">SelectorRunner</emphasis>'s queue, which is
        being processed from selector-thread. Within the selector-thread the
        connection will be actually registered on the <emphasis
        role="italic">SelectorRunner</emphasis>'s associated Selector and,
        once it happens, the <emphasis role="italic">SelectorRunner</emphasis>
        notifies <emphasis role="italic">ConnectorHandler</emphasis> about the
        registration completion and<itemizedlist>
            <listitem>
              <para>for UDP transport - <emphasis
              role="italic">UDPNIOConnection</emphasis> gets initialized. The
              <emphasis role="italic">Processor</emphasis> gets notified about
              CONNECT operation completion and finally the <emphasis
              role="italic">Future&lt;Connection&gt;</emphasis> result becomes
              available in the custom-thread;</para>
            </listitem>

            <listitem>
              <para>for TCP transport - we still wait until underlying OS
              network framework notifies the framework that the connection was
              actually connected to the destination address (UDP doesn't have
              this) and only then <emphasis role="italic">Processor</emphasis>
              gets notified about CONNECT operation completion and finally the
              <emphasis role="italic">Future&lt;Connection&gt;</emphasis>
              result becomes available in the custom-thread;</para>
            </listitem>
          </itemizedlist></para>

        <para>In general the logic looks like:</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/connectorhandler-seq2.png"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>When talking about TCP transport, when we're on the server side
        and <emphasis role="italic">TCPNIOServerConnection</emphasis> accepts
        new client connection. In this case the processing logic looks pretty
        much like the diagram above, but instead of "CONNECT" we notify
        <emphasis role="italic">Processor</emphasis> about "ACCEPT" event
        having occurred on the <emphasis
        role="italic">TCPNIOConnection</emphasis>.</para>
      </listitem>
    </itemizedlist></para>
</section>
