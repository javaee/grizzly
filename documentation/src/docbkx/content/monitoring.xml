<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter version="5.0" xml:id="monitoring"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>Monitoring</title>

  <para>The ability to provide data of how an application is being used at
  runtime is an important feature offered by many frameworks. Grizzly @project.version@ is
  no exception. Grizzly provides the ability to monitor key components within
  the framework and allows this monitoring to be extended by custom authored
  components. Let's start by looking at the entities that enable monitoring
  within Grizzly.</para>

  <section xml:id="monitoring-core">
    <title>Core Monitoring Artifacts</title>

    <para>At the core of Grizzly monitoring are three simple artifacts in the
    <emphasis role="italic">org.glassfish.grizzly.monitoring
    package</emphasis>. The first being called <emphasis
    role="italic">MonitoringAware</emphasis> which denotes an entity may be
    monitored:</para>

    <programlisting language="java" linenumbering="numbered">/**
 * General interface for the objects, which could be monitored during the lifecycle.
 * 
 * @author Alexey Stashok
 */
public interface MonitoringAware&lt;E&gt; {
    /**
     * Return the object associated {@link MonitoringConfig}.
     *
     * @return the object associated {@link MonitoringConfig}.
     */
    MonitoringConfig&lt;E&gt; getMonitoringConfig();
}</programlisting>

    <para>Entities such a <emphasis role="italic">MemoryManager</emphasis>,
    <emphasis role="italic">Transport</emphasis>, etc are all <emphasis
    role="italic">MonitoringAware</emphasis>. As seen by the interface
    definition, all <emphasis role="italic">MonitoringAware</emphasis>
    entities return a <emphasis role="italic">MonitoringConfig</emphasis>
    object with which you can register monitoring probes.</para>

    <programlisting language="java" linenumbering="numbered">/**
 * General monitoring configuration interface.
 *
 * @author Alexey Stashok
 */
public interface MonitoringConfig&lt;E&gt; {
    /**
     * Add the monitoring probes, which will be notified about object's lifecycle events.
     *
     * @param probes the monitoring probes.
     */
    public void addProbes(E... probes);

    /**
     * Remove the monitoring probes.
     *
     * @param probes the monitoring probes.
     */
    public boolean removeProbes(E... probes);

    /**
     * Get the the monitoring probes, which are registered on the objet.
     * Please note, it's not appropriate to modify the returned array's content.
     * Please use {@link #addProbes(Object[])} and
     * {@link #removeProbes(Object[])} instead.
     *
     * @return the the monitoring probes, which are registered on the object.
     */
    public E[] getProbes();

    /**
     * Removes all the monitoring probes, which are registered on the object.
     */
    public void clearProbes();
}
</programlisting>

    <para>Since <emphasis role="italic">MonitoringConfig</emphasis> is really
    nothing more than a simplified collection, Grizzly provides a default
    implementation called <emphasis
    role="italic">org.glassfish.grizzly.monitoring.MonitoringConfigImpl</emphasis>.
    This should be able to satisfied most developer needs.</para>

    <para>Monitoring probes, as seen in the code example above, can be of any
    type. Grizzly provides probe interfaces for all MonitoringAware entites
    within the framework.</para>

    <table>
      <title>Core Module Probes</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>org.glassfish.grizzly.TransportProbe</entry>

            <entry>Provides details on events happening within a particular
            Transport. Such events include when the transport is started,
            stopped, an error occurring, or if the transport's configuration
            has been changed.</entry>
          </row>

          <row>
            <entry>org.glassfish.grizzly.ConnectionProbe</entry>

            <entry>Provides details on Connections within the framework. This
            includes both binding of server-side sockets, or inbound
            connections from clients.</entry>
          </row>

          <row>
            <entry>org.glassfish.grizzly.memory.MemoryProbe</entry>

            <entry>Provides buffer allocation (both pooled and
            non-pooled)/deallocation events.</entry>
          </row>

          <row>
            <entry>org.glassfish.grizzly.threadpool.ThreadPoolProbe</entry>

            <entry>Provides details relating to the lifecycle of the
            threadpool itself as well as that of the threads it manages as
            well as delegated task information.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Http Module Probes</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>org.glassfish.grizzly.http.HttpProbe</entry>

            <entry>Provides details related to the HTTP codec processing
            itself. Details such as the parsing headers, content chunks, as
            well as the reverse when content is serialized to the
            wire.</entry>
          </row>

          <row>
            <entry>org.glassfish.grizzly.http.KeepAliveProbe</entry>

            <entry>Provides details pertaining to HTTP keep-alive
            statistics.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Http Server Module Probes</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>org.glassfish.grizzly.http.server.HttpServerProbe</entry>

            <entry>Provides details relating to request processing lifecycles,
            such as request started, completed, suspended, timed-out, or
            cancelled.</entry>
          </row>

          <row>
            <entry>org.glassfish.grizzly.http.server.filecache.FileCacheProbe</entry>

            <entry>Provides file cache statistics such as a entry being
            cached, removed from the cache, and cache hits/misses.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section xml:id="monitoring-jmx">
    <title>JMX</title>

    <para>No monitoring would be complete without support form JMX. Given
    that, Grizzly does provide out-of-the-box support for JMX, however, in
    order to make our lives easier, we've decided to use another open source
    library called <link
    xlink:href="http://kenai.com/projects/gmbal/pages/Home">GMBAL</link>
    (pronounced "gumball") upon which to build our JMX support. To make our
    footprint lighter, be default, we only include the stub GMBAL jar that
    no-ops all GMBAL related operations, so in order to enable JMX support,
    the full GMBAL jar needs to be included in the application's classpath. If
    your project is maven based, this is easy: include a dependency
    like:</para>

    <programlisting language="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.gmbal&lt;/groupId&gt;
    &lt;artifactId&gt;gmbal&lt;/artifactId&gt;
    &lt;version&gt;3.0.0-b023&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

    <para>or the jar can be downloaded from <link
    xlink:href="http://download.java.net/maven/2/org/glassfish/gmbal/gmbal/">http://download.java.net/maven/2/org/glassfish/gmbal/gmbal/</link>.</para>

    <section>
      <title>JMX Core Monitoring Artifacts</title>

      <para>As before, there are artifacts to enable JMX support within the
      Grizzly runtime. In fact, they are simply extensions to <emphasis
      role="italic">MonitoringAware</emphasis> and <emphasis
      role="italic">MonitoringConfig</emphasis> within the <emphasis
      role="italic">org.glassfish.grizzly.monitoring.jmx</emphasis> package.
      The JMX equivalent of <emphasis role="italic">MonitoringAware</emphasis>
      is <emphasis role="italic">JmxMonitoringAware</emphasis>:</para>

      <programlisting language="java" linenumbering="numbered">/**
 * The interface, which could be used by the objects, which support JMX monitoring.
 * 
 * @author Alexey Stashok
 */
public interface JmxMonitoringAware&lt;E&gt; extends MonitoringAware&lt;E&gt; {
    /**
     * Return the object associated {@link JmxMonitoringConfig}.
     *
     * @return the object associated {@link JmxMonitoringConfig}.
     */
    @Override
    public JmxMonitoringConfig&lt;E&gt; getMonitoringConfig();
}</programlisting>

      <para>and the equivalent of <emphasis
      role="italic">MonitoringConfig</emphasis>, in case you didn't guess it,
      is <emphasis role="italic">JmxMonitoringConfig</emphasis>:</para>

      <programlisting language="java" linenumbering="numbered">/**
 * JMX monitoring configuration interface.
 *
 * @author Alexey Stashok
 */
public interface JmxMonitoringConfig&lt;E&gt; extends MonitoringConfig&lt;E&gt; {
    /**
     * Create the {@link JmxObject}, which represents this object.
     *
     * @return the {@link JmxObject}, which represents this object.
     */
    public JmxObject createManagementObject();
}</programlisting>

      <para>For ease of development, the class
      org.glassfish.grizzly.monitoring.jmx.AbstractJmxMonitoringConfig is
      provided for convenience:</para>

      <programlisting>/**
 * The abstract class, which represents the JMX aware configuration object.
 * 
 * @author Alexey Stashok
 */
public abstract class AbstractJmxMonitoringConfig&lt;E&gt; extends MonitoringConfigImpl&lt;E&gt;
        implements JmxMonitoringConfig&lt;E&gt; {

    public AbstractJmxMonitoringConfig(Class&lt;E&gt; clazz) {
        super(clazz);
    }
}</programlisting>

      <para>What about the JmxObject that must be implemented? The JmxObject
      implementation describes the entity that will be registered with the JMX
      runtime. The concrete JmxObject implementation typically wraps the
      Grizzly artifact to be managed. Here is a relatively simple
      example:</para>

      <programlisting language="java" linenumbering="numbered"
                      startinglinenumber="54">/**
 * JMX management object for {@link org.glassfish.grizzly.http.KeepAlive}.
 *
 * @since 2.0
 */
@ManagedObject
@Description("The configuration for HTTP keep-alive connections.")
public class KeepAlive extends JmxObject {
    /**
     * The {@link org.glassfish.grizzly.http.KeepAlive} being managed.
     */
    private final org.glassfish.grizzly.http.KeepAlive keepAlive;

    /**
     * The number of live keep-alive connections.
     */
    private final AtomicInteger keepAliveConnectionsCount = new AtomicInteger();

    /**
     * The number of requests processed on a keep-alive connections.
     */
    private final AtomicInteger keepAliveHitsCount = new AtomicInteger();

    /**
     * The number of times keep-alive mode was refused.
     */
    private final AtomicInteger keepAliveRefusesCount = new AtomicInteger();

    /**
     * The number of times idle keep-alive connections were closed by timeout.
     */
    private final AtomicInteger keepAliveTimeoutsCount = new AtomicInteger();

    /**
     * The {@link JMXKeepAliveProbe} used to track keep-alive statistics.
     */
    private final JMXKeepAliveProbe keepAliveProbe = new JMXKeepAliveProbe();
    
    // ------------------------------------------------------------ Constructors


    /**
     * Constructs a new JMX managed KeepAlive for the specified
     * {@link org.glassfish.grizzly.http.KeepAlive} instance.
     *
     * @param keepAlive the {@link org.glassfish.grizzly.http.KeepAlive}
     *  to manage.
     */
    public KeepAlive(org.glassfish.grizzly.http.KeepAlive keepAlive) {
        this.keepAlive = keepAlive;
    }

    // -------------------------------------------------- Methods from JmxObject


    /**
     * {@inheritDoc}
     */
    @Override
    public String getJmxName() {
        return "Keep-Alive";
    }

    /**
     * &lt;p&gt;
     * {@inheritDoc}
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When invoked, this method will add a {@link KeepAliveProbe} to track
     * statistics.
     * &lt;/p&gt;
     */
    @Override
    protected void onRegister(GrizzlyJmxManager mom, GmbalMBean bean) {
        keepAlive.getMonitoringConfig().addProbes(keepAliveProbe);
    }

    /**
     * &lt;p&gt;
     * {@inheritDoc}
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When invoked, this method will remove the {@link KeepAliveProbe} added
     * by the {@link #onRegister(GrizzlyJmxManager, GmbalMBean)}
     * call.
     * &lt;/p&gt;
     */
    @Override
    protected void onDeregister(GrizzlyJmxManager mom) {
        keepAlive.getMonitoringConfig().removeProbes(keepAliveProbe);
    }

    // --------------------------------------------------- Keep Alive Properties


    /**
     * @see org.glassfish.grizzly.http.KeepAlive#getIdleTimeoutInSeconds()
     */
    @ManagedAttribute(id="idle-timeout-seconds")
    @Description("The time period keep-alive connection may stay idle")
    public int getIdleTimeoutInSeconds() {
        return keepAlive.getIdleTimeoutInSeconds();
    }

    /**
     * @see org.glassfish.grizzly.http.KeepAlive#getMaxRequestsCount()
     */
    @ManagedAttribute(id="max-requests-count")
    @Description("the max number of HTTP requests allowed to be processed on one keep-alive connection")
    public int getMaxRequestsCount() {
        return keepAlive.getMaxRequestsCount();
    }

    /**
     * @return the number live keep-alive connections.
     */
    @ManagedAttribute(id="live-connections-count")
    @Description("The number of live keep-alive connections")
    public int getConnectionsCount() {
        return keepAliveConnectionsCount.get();
    }

    /**
     * @return the number of requests processed on a keep-alive connections.
     */
    @ManagedAttribute(id="hits-count")
    @Description("The number of requests processed on a keep-alive connections.")
    public int getHitsCount() {
        return keepAliveHitsCount.get();
    }

    /**
     * @return the number of times keep-alive mode was refused.
     */
    @ManagedAttribute(id="refuses-count")
    @Description("The number of times keep-alive mode was refused.")
    public int getRefusesCount() {
        return keepAliveRefusesCount.get();
    }

    /**
     * @return the number of times idle keep-alive connections were closed by timeout.
     */
    @ManagedAttribute(id="timeouts-count")
    @Description("The number of times idle keep-alive connections were closed by timeout.")
    public int getTimeoutsCount() {
        return keepAliveTimeoutsCount.get();
    }

    // ---------------------------------------------------------- Nested Classes


    /**
     * JMX statistic gathering {@link KeepAliveProbe}.
     */
    private final class JMXKeepAliveProbe implements KeepAliveProbe {

        @Override
        public void onConnectionAcceptEvent(Connection connection) {
            keepAliveConnectionsCount.incrementAndGet();
            connection.addCloseListener(new Connection.CloseListener() {

                @Override
                public void onClosed(Closeable closeable) throws IOException {
                    keepAliveConnectionsCount.decrementAndGet();
                }
            });
        }

        @Override
        public void onHitEvent(Connection connection, int requestCounter) {
            keepAliveHitsCount.incrementAndGet();
        }

        @Override
        public void onRefuseEvent(Connection connection) {
            keepAliveRefusesCount.incrementAndGet();
        }

        @Override
        public void onTimeoutEvent(Connection connection) {
            keepAliveTimeoutsCount.incrementAndGet();
        }


        // ----------------------------------------- Methods from KeepAliveProbe


    } // END JMXKeepAliveProbe
}</programlisting>

      <para>There are several things going on here that warrant
      explaination.</para>

      <itemizedlist>
        <listitem>
          <para>Line 59: Declared as a JMX managed entitied via the
          @ManagedObject annotation from GMBAL. This annotation must be
          present on the entities to be managed by JMX in order for GMBAL to
          do its magic.</para>
        </listitem>

        <listitem>
          <para>Line 102: Constructor taking in an actual
          org.glassfish.grizzly.http.KeepAlive instance. This is needed as the
          actual KeepAlive instance has the monitoring config where probes can
          be registered.</para>
        </listitem>

        <listitem>
          <para>Line 113: Returns the name to be displayed via JMX.</para>
        </listitem>

        <listitem>
          <para>Line 128: This callback will be invoked by the GMBAL runtime
          when this @ManagedObject is registered with JMX. It's at this point
          in time that we register the probe implementation (starting at line
          208) with the KeepAlive instance's <emphasis
          role="italic">JmxMonitoringConfig</emphasis>.</para>
        </listitem>

        <listitem>
          <para>Line 144: This callback will be invoked by the GMBAL runtime
          when this @ManagedObject is de-registered with JMX. It's at this
          point in time that we remove the probe implementation (starting at
          line 208) with the KeepAlive instance's <emphasis
          role="italic">JxmMonintoringConfig</emphasis>.</para>
        </listitem>

        <listitem>
          <para>Lines 151-203: These define @ManagedAttributes along with
          their descriptions which will be exposed via JMX.</para>
        </listitem>
      </itemizedlist>

      <para>Using the example JmxObject implementation above, the
      org.glassfish.grizzly.http.KeepAlive.createJmxManagementObject() is
      simple:</para>

      <programlisting language="java" linenumbering="numbered">protected JmxObject createJmxManagementObject() {
    return new org.glassfish.grizzly.http.jmx.KeepAlive(this);
}</programlisting>

      <para>The final piece here is how to actually hook into the JMX runtime.
      It's easy!</para>

      <programlisting language="java">public static void main(String[] args) {

        final GrizzlyJmxManager manager = GrizzlyJmxManager.instance();
        final TCPNIOTransport transport1 = TCPNIOTransportBuilder.newInstance().build();
        final TCPNIOTransport transport2 = TCPNIOTransportBuilder.newInstance().build();
        try {
            JmxObject jmxTransportObject1 =
                    transport1.getMonitoringConfig().createManagementObject();

            JmxObject jmxTransportObject2 =
                    transport2.getMonitoringConfig().createManagementObject();

            manager.registerAtRoot(jmxTransportObject1, "Transport1");
            manager.registerAtRoot(jmxTransportObject2, "Transport2");
            transport1.start();
            transport1.bind(9999);
            System.out.println("Press any key to stop the example...");
            System.in.read();
        } catch (IOException ioe) {
            ioe.printStackTrace();
            System.exit(1);
        } finally {
            try {
                transport1.stop();
            } catch (IOException ignored) {}
        }
}</programlisting>

      <para>Once running, you can connect to the process via JConsole and
      inspect the results (e.g., see that Transport1 is started while
      Transport2 is stopped).</para>
    </section>
  </section>

  <section xml:id="monitoring-http-server">
    <title>Grizzly HTTP JMX Server Monitoring</title>

    <para>If you're using Grizzly's HttpServer, enabling monitoring is very
    simple:</para>

    <programlisting>public static void main(String[] args) {

        HttpServer gws = new HttpServer();
        HttpServer gws1 = new HttpServer();
        NetworkListener listener1 = new NetworkListener("listener1", "localhost", 19080);
        NetworkListener listener2 = new NetworkListener("listener2", "localhost", 19081);
        gws.addListener(listener1);
        gws1.addListener(listener2);

        try {
            gws.start();
            gws1.start();
            gws.getServerConfiguration().setJmxEnabled(true);
            gws1.getServerConfiguration().setJmxEnabled(true);
            assertTrue(true);
        } catch (IOException ioe) {
            ioe.printStackTrace();
            System.exit(1);
        } finally {
            try {
                gws.stop();
                gws1.stop();
            } catch (IOException ignored) {}
        }
}</programlisting>

    <para>Notice that enabling or disabling JMX support is dynamic - no need
    to restart the server instances.</para>
  </section>
</chapter>
