<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="filterchain-filters"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>FilterChain and Filters</title>
  <para>In the previous sections we mentioned <emphasis role="italic">Processor</emphasis>, and its
        role - processing I/O events occurred on Grizzly <emphasis role="italic"
            >Connection</emphasis>s. The <emphasis role="italic">FilterChain</emphasis> is the most
        useful type of <emphasis role="italic">Processor</emphasis> used in Grizzly.</para>
    <para><inlinemediaobject>
            <imageobject>
                <imagedata fileref="../images/coreframework/filterchain-diagram.svg"/>
            </imageobject>
        </inlinemediaobject></para>
    <para><emphasis role="italic">FilterChain</emphasis>, according to its name, is a chain of
            <emphasis role="italic">Filter</emphasis>s. Each <emphasis role="italic"
            >Filter</emphasis> represents a unit of processing work to be performed, whose purpose
        it to examine and/or modify the state of the transaction that is represented by a <emphasis
            role="italic">FilterChainContext</emphasis>.</para>
    <para>To give an idea how <emphasis role="italic">FilterChain</emphasis> may look like, here is
        example of <emphasis role="italic">FilterChain</emphasis>, which implements HTTP server
        logic:</para>
    <para><inlinemediaobject>
            <imageobject>
                <imagedata fileref="../images/coreframework/http-filterchain.svg"/>
            </imageobject>
        </inlinemediaobject></para>
    <para>
        <itemizedlist>
            <listitem>
                <para>TransportFilter is responsible to read data from network <emphasis
                        role="italic">Connection</emphasis> to a <emphasis role="italic"
                        >Buffer</emphasis>, and to write data from <emphasis role="italic"
                        >Buffer</emphasis> to a nework <emphasis role="italic"
                    >Connection</emphasis></para>
            </listitem>
            <listitem>
                <para>HttpFilter is responsible for <emphasis role="italic">Buffer</emphasis> &lt;->
                        <emphasis role="italic">HttpPacket</emphasis> transformation (both
                    directions)</para>
            </listitem>
            <listitem>
                <para>HttpServerFilter is responsible for processing request <emphasis role="italic"
                        >HttpPacket</emphasis>s and generating response <emphasis role="italic"
                        >HttpPacket</emphasis>s and send them back on <emphasis role="italic"
                        >FilterChain</emphasis> in opposite direction
                    (HttpServerFilter->HttpFilter->TransportFilter).</para>
            </listitem>
        </itemizedlist>
    </para>
    <para>So, what if we want to implement HTTPS server? It's simple:</para>
    <para><inlinemediaobject>
            <imageobject>
                <imagedata fileref="../images/coreframework/https-filterchain.svg"/>
            </imageobject>
        </inlinemediaobject></para>
    <para>we add just one SSLFilter, responsible for encoding/decoding SSL secured data.</para>
    <para>As we see, during the processing of any I/O Event, Filters in a FilterChain will be
        executed in the certain order. <emphasis role="bold">It's important to remember that the
            most of I/O Events are processed starting from first filter to last (from left to right
            on the schema above), except WRITE event, whose processing starts from last Filter in
            chain to first (from right to left a the schema above).</emphasis></para>
    <para>Let's define some <emphasis role="bold">terminology</emphasis> to make further description
        more clear:<itemizedlist>
            <listitem>
                <para><emphasis role="bold">Upstream</emphasis> - direction from this Filter to the
                    last Filter in chain (from left to right on the schema above);</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">Downstream</emphasis> - direction from this Filter to
                    the first Filter in chain (from right to left on the schema above);</para>
            </listitem>
        </itemizedlist></para>
    <para>Let's take a look which I/O events could be processed by a <emphasis role="italic"
            >FilterChain</emphasis>, for that purpose we can just take a look at the <emphasis
            role="italic">Filter</emphasis> interface
        methods:<programlisting>public NextAction handleRead(FilterChainContext ctx) throws IOException;

public NextAction handleWrite(FilterChainContext ctx) throws IOException;

public NextAction handleConnect(FilterChainContext ctx) throws IOException;

public NextAction handleAccept(FilterChainContext ctx) throws IOException;

public NextAction handleClose(FilterChainContext ctx) throws IOException;</programlisting></para>
    <para>so I/O events are<itemizedlist>
            <listitem>
                <para>READ: some data has come on a Connection, which could be read and
                    processed;</para>
            </listitem>
            <listitem>
                <para>WRITE: some data is going to be written to Connection, and Filter might be
                    responsible to transform data representation form, like <emphasis role="italic"
                        >HttpPacket</emphasis> -> <emphasis role="italic">Buffer</emphasis> on
                    schema above;</para>
            </listitem>
            <listitem>
                <para>CONNECT: new client <emphasis role="italic">Connection</emphasis> has been
                    connected;</para>
            </listitem>
            <listitem>
                <para>ACCEPT (TCP only): new client <emphasis role="italic">Connection</emphasis>
                    has been accepted by server <emphasis role="italic">Connection</emphasis>
                        (<emphasis role="italic">TCPNIOServerConnection</emphasis>);</para>
            </listitem>
            <listitem>
                <para>CLOSE: the Connection has been closed (either locally or by peer);</para>
            </listitem>
        </itemizedlist></para>
    <para><emphasis role="bold">Important to remember that the same I/O events on the specific
            Connection are processed serially. For example, if we process READ I/O event on
            Connection "A", Grizzly will never start the processing of another READ I/O event on the
            same Connection "A", until previous processing won't be finished, or user won't
            explicitly do that in his code. If the latter - it's becoming responsibility of user to
            follow the rule of I/O events processing seriality</emphasis></para>
    <para>Additionally FilterChain Filters are able to initiate and handle custom event
        notifications. The event initiator may chose to emit the event up or down stream by
        FilterChain
        like:<programlisting>public NextAction handleRead(FilterChainContext ctx) throws IOException {
        // Here we decide to notify downstream Filters
        ctx.notifyDownstream(new MyEvent(...));

        // Notify upstream Filters
        ctx.notifyUpstream(new AnotherEvent(...));
}</programlisting></para>
    <para>The Filters in FilterChain are able to intercept and process custom Events by implementing
        method:<programlisting>public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException;</programlisting></para>
    <para>As we see each Filter handle method has FilterChainContext parameter and returns
        NextAction result.</para>
    <para>
        <itemizedlist>
            <listitem>
                <para><emphasis role="bold">FilterChainContext</emphasis></para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../images/coreframework/filterchaincontext.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>FilterChainContext represents a context (state), associated with processing of
                    specific I/O event on the specific Connection, so its lifecycle is bound to a
                    single I/O event processing.</para>
                <para>FilterChainContext contains following state information:<itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">Connection</emphasis></para>
                            <para>The Connection I/O event occurred on;</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Address</emphasis></para>
                            <para>The peer address. In most case it returns the same value as
                                    <emphasis role="italic">Connection.getPeerAddress()</emphasis>,
                                except the case when we handle READ event on unbound UDP Connection.
                                In this case the <emphasis role="italic"
                                    >FilterChainContext.getAddress()</emphasis> will return the
                                address of peer, which sent data;</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Message</emphasis></para>
                            <para>The message being processed. This is the only modifiable value
                                Filters may change during the I/O event processing. Usually it is
                                used during the incoming/outgoing message parsing/serializing. Each
                                Filter is able to take initial message data, transform it to a
                                different representation, set it back and pass processing to the
                                next Filter in chain.</para>
                            <para>For example, when handling READ event, HttpFilter gets message for
                                FilterChainContext as Grizzly Buffer, transforms it to a HttpPacket,
                                sets HttpPacket back as FilterChainContext message and passes
                                control to a HttpServerFilter, which will get HttpPacket from the
                                FilterChainContext and process it.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Besides holding the state, FilterChainContext provides support for commonly
                    used I/O operations:<itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">Read</emphasis></para>
                            <para>
                                <programlisting>ReadResult readResult = ctx.read();</programlisting>
                            </para>
                            <para>This operation performs blocking FilterChain read starting at the
                                first Filter in chain (inclusive) upstream to this Filter
                                (exlusive).</para>
                            <para>The operation will return a result, when during processing READ
                                I/O event, FilterChain will be about to call handleRead(...)
                                operation of this Filter.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold"
                                >Write</emphasis><programlisting>ctx.write(message);

or

ctx.write(message, completionHandler);

or

ctx.write(address, message, completionHandler);  // Unbound UDP only</programlisting></para>
                            <para>This operation performs FilterChain write starting at this Filter
                                (exclusive) downstream to the first Filter (inclusive). This
                                operation initiates processing of WRITE I/O event on the FilterChain
                                starting from this Filter (exclusive).</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold"
                                >Flush</emphasis><programlisting>ctx.flush();

or

ctx.flush(completionHandler);</programlisting></para>
                            <para>This operation initializes and notifies downstream filters about
                                special <emphasis role="italic"
                                    >TransportFilter.FlushEvent</emphasis> so each Filter is able to
                                handle this event and make sure all the cached data was written on
                                the Connection.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Event
                                notification</emphasis><programlisting>ctx.notifyUpstream(event);

or

ctx.notifyDownstream(event);</programlisting></para>
                            <para>This operations notify all the upstream/downstream Filters in the
                                FilterChain about specific <emphasis role="italic"
                                    >FilterChainEvent</emphasis>.</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">NextAction</emphasis></para>
                <para>As it was mentioned, during processing I/O Event, FilterChain is calling
                    Filters one by one from first to last except WRITE event, which is being
                    processed from last Filter to first. At the same time Filters can change default
                    I/O Event processing order by returning different types of NextAction:<itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">InvokeAction</emphasis></para>
                            <para>
                                <programlisting>return ctx.getInvokeAction();</programlisting>
                            </para>
                            <para>instructs FilterChain to run next Filter in chain according to the
                                natural execution order.</para>
                            <para>It's possible to create the InvokeAction with a remainder
                                parameter:</para>
                            <para>
                                <programlisting>return ctx.getInvokeAction(remainder);</programlisting>
                            </para>
                            <para>this instructs FilterChain to store the remainder aside and
                                continue FilterChain execution like it was with non-parameterized
                                version, but once FilterChain execution completes - FilterChain will
                                restore the remainder of the most recent Filter in chain and
                                reinitiate FilterChain processing starting from the Filter, which
                                stored the remainder.</para>
                            <para>This feature is very useful, when we parse a message from the
                                source Buffer and realize, that the Buffer contains several messages
                                at once, so we'd want to extract just one message from it and save
                                the remainder to be processed once this message will be
                                processed.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">StopAction</emphasis></para>
                            <para>
                                <programlisting>return ctx.getStopAction();</programlisting>
                            </para>
                            <para>instructs FilterChain to stop the processing of this I/O Event.
                                Usually StopAction is returned if we don't have enough data to
                                continue FilterChain processing, or it's the last Filter in the
                                chain.</para>
                            <para>Like InvokeAction, StopAction also could be
                                parameterized<programlisting>return ctx.getStopAction(remainder);

or

return ctx.getStopAction(remainder, appender);</programlisting></para>
                            <para>The remainder in the StopAction has similar meaning as remainder
                                in InvokeAction, but it's not the same. Remainder in StopAction
                                means we don't have enough data to continue FilterChain processing,
                                so when more data will be available and FilterChain will be about to
                                call the Filter - it will check if the Filter has any data stored
                                after the last invocation, if yes - it will append new data chunk to
                                the stored one and pass the result in the FilterChainContext
                                message.</para>
                            <para>Unlike remainder in the InvokeAction, the StopAction remainder
                                should be "appendable", so FilterChain will know how new data chunk
                                should be appended to the stored one. So the remainder should either
                                implement <emphasis role="italic"
                                    >org.glassfish.grizzly.Appendable</emphasis> or <emphasis
                                    role="italic">org.glassfish.grizzly.Appender</emphasis> should
                                be passed as additional parameter.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold"
                                >RerunFilterAction</emphasis><programlisting>return ctx.getRerunFilterAction();</programlisting></para>
                            <para>Instructs FilterChain to rerurn this Filter one more time. Might
                                be useful to simplify I/O event processing code, avoid
                                recursions.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">SuspendAction</emphasis></para>
                            <programlisting>return ctx.getSuspendAction();</programlisting>
                            <para>Instructs FilterChain to terminate (leave) the I/O event
                                processing in the current thread. User will be able to resume the
                                I/O event processing by
                                calling<programlisting>ctx.resume();</programlisting></para>
                            <para>Once <emphasis role="italic">ctx.resume()</emphasis> is called,
                                FilterChain resumes processing at the same Filter it was
                                suspended.</para>
                            <para>Please note, after returning SuspendAction and before I/O event
                                processing will be resumed, Grizzly supposes I/O event as being
                                processed, so Grizzly won't initialize the same I/O event processing
                                on the same Connection. For example if we return the SuspendAction
                                during READ event processing - Grizzly won't notify FilterChain
                                about any new data coming on the same Connection, until READ event
                                processing won't be completed.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold"
                                >SuspendStopAction</emphasis><programlisting>return ctx.getSuspendStopAction();</programlisting></para>
                            <para>This NextAction is very similar to SuspendAction, except one
                                important thing - after getting SuspendStopAction, Grizzly will keep
                                listening for the same I/O events on the Connection and notify
                                FilterChain if they occur.</para>
                            <para>We have to be very careful with this NextAction and make sure two
                                or more threads are not processing the same I/O operation
                                simultaneously.</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
        </itemizedlist>
    </para>
</section>
