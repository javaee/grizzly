
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2021-03-19
 Rendered using Reflow Maven Skin 1.1.1 (http://andriusvelykis.github.io/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>Project Grizzly - WebSockets Overview</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />
 
		<link href="//netdna.bootstrapcdn.com/bootswatch/2.3.2/cosmo/bootstrap.min.css" rel="stylesheet" />
		<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/bootswatch.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/reflow-skin.css" rel="stylesheet" />

		<link href="//yandex.st/highlightjs/7.5/styles/solarized_dark.min.css" rel="stylesheet" />

		<link href="https://javaee.github.io/grizzly//css/lightbox.css" rel="stylesheet" />

		<link href="https://javaee.github.io/grizzly//css/site.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/print.css" rel="stylesheet" media="print" />

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->



	</head>

	<body class="page-websockets project-site" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#top-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html">Project <span class="color-brown">Grizzly</span></a>
					<div class="nav-collapse collapse" id="top-nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="dependencies.html" title="Download">Download</a></li>
								</ul>
							</li>
							<li class="dropdown active">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="overview.html" title="Overview">Overview</a></li>
									<li ><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
									<li class="dropdown-submenu ">
										<a href="hack" title="Core Framework">Core Framework</a>
										<ul class="dropdown-menu">
											<li ><a href="memory.html" title="Memory Management">Memory Management</a></li>
											<li ><a href="iostrategies.html" title="I/O Strategies">I/O Strategies</a></li>
											<li ><a href="transportsconnections.html" title="Transports and Connections">Transports and Connections</a></li>
											<li ><a href="filterchainfilters.html" title="FilterChain and Filters">FilterChain and Filters</a></li>
											<li ><a href="coreconfig.html" title="Core configuration">Core configuration</a></li>
											<li ><a href="portunification.html" title="Port Unification">Port Unification</a></li>
											<li ><a href="monitoring.html" title="Monitoring">Monitoring</a></li>
											<li ><a href="extras.html" title="Extras">Extras</a></li>
											<li ><a href="bestpractices.html" title="Best Practices">Best Practices</a></li>
											<li ><a href="quickstart.html" title="Quick Start">Quick Start</a></li>
											<li ><a href="samples.html" title="Samples">Samples</a></li>
										</ul>
									</li>
									<li class="dropdown-submenu ">
										<a href="hack" title="HTTP">HTTP</a>
										<ul class="dropdown-menu">
											<li ><a href="httpframework.html" title="Core HTTP Framework">Core HTTP Framework</a></li>
											<li ><a href="httpserverframework.html" title="HTTP Server Framework">HTTP Server Framework</a></li>
											<li ><a href="http2.html" title="HTTP/2">HTTP/2</a></li>
											<li ><a href="httpserverframeworkextras.html" title="HTTP Server Framework Extras">HTTP Server Framework Extras</a></li>
											<li ><a href="comet.html" title="Comet">Comet</a></li>
											<li ><a href="jaxws.html" title="JAXWS">JAXWS</a></li>
											<li class="active"><a href="" title="WebSockets">WebSockets</a></li>
											<li ><a href="ajp.html" title="AJP">AJP</a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>

	<div class="container">

	<!-- Masthead
	================================================== -->

	<header>
	<div class="jumbotron subhead">
		<div class="row" id="banner">
			<div class="span12">
				<div class="pull-left">
					<a href="index.html" id="bannerLeft"><h1><img src="images/grizzlyHead.png"/>&nbsp;<span class="color-black">Project</span> Grizzly</h1></a>
					<p class="lead">NIO Event Development Simplified</p>
				</div>
				<div class="pull-right">
				</div>
			</div>
		</div>
	</div>
		<div>
			<ul class="breadcrumb">
				<li class="publishDate version-date">Last Published: 2021-03-19</li>
			</ul>
		</div>
		<hr class="toc-separator" />
		<div id="toc-bar" class="navbar" data-spy="affix" data-offset-top="250">
			<div class="navbar-inner">
				<div id="toc-scroll-target" class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#toc-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<div class="nav-collapse collapse" id="toc-nav-collapse">
						<ul id="toc" class="nav">
						<li class="toplevel"><a href="#WebSockets_Overview" title="WebSockets Overview">WebSockets Overview</a></li>
						<li class="divider-vertical"></li>
						<li class="toplevel"><a href="#Overview_of_Grizzlys_WebSocket_Implementation" title="Overview of Grizzly’s WebSocket Implementation">Overview of Grizzly’s WebSocket Implementation</a></li>
						<li class="divider-vertical"></li>
						<li class="dropdown">
							<a href="#The_Grizzly_WebSocket_API" title="The Grizzly WebSocket API" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">The Grizzly WebSocket API <b class="caret"></b></a>
							<ul class="dropdown-menu" role="menu">
								<!-- Repeat the item, otherwise it is not clickable as the dropdown root -->
								<li><a href="#The_Grizzly_WebSocket_API" title="The Grizzly WebSocket API">The Grizzly WebSocket API</a></li>
								<li class="divider"></li>
								<li><a href="#WebSocket" title="WebSocket">WebSocket</a></li>
								<li><a href="#Broadcaster" title="Broadcaster">Broadcaster</a></li>
								<li><a href="#WebSocketListener" title="WebSocketListener">WebSocketListener</a></li>
								<li><a href="#WebSocketApplication" title="WebSocketApplication">WebSocketApplication</a></li>
								<li><a href="#WebSocketEngine" title="WebSocketEngine">WebSocketEngine</a></li>

							</ul>
						</li>
						<li class="divider-vertical"></li>
						<li class="toplevel"><a href="#Using_Grizzly_2_WebSockets_on_the_Server-Side" title="Using Grizzly 2 WebSockets on the Server-Side">Using Grizzly 2 WebSockets on the Server-Side</a></li>
		<li class="divider-vertical"></li>
		<li class="dropdown">
			<a href="#" title="More&hellip;" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#">&hellip; <b class="caret"></b></a>
			<ul class="dropdown-menu" role="menu">
								<li><a href="#Grizzly_WebSockets_Client" title="Grizzly WebSockets Client">Grizzly WebSockets Client</a></li>

			</ul>
		</li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="section"> 
 <div class="page-header">
  <h2 id="WebSockets_Overview">WebSockets Overview</h2>
 </div> 
 <p>Quoting the description from <a class="externalLink" href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>:</p> 
 <blockquote> 
  <p>The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment.</p> 
 </blockquote> 
 <p>For further details on the protocol itself, the RFC referenced previously is your best source of information.</p> 
</div> 
<div class="section"> 
 <h2 id="Overview_of_Grizzlys_WebSocket_Implementation">Overview of Grizzly’s WebSocket Implementation</h2> 
 <p>Grizzly 2 implements the requirements of RFC 6455, however we do include support for older versions of the protocol. This is particularly useful for clients that haven’t caught up with the final draft of the specification. That said, please consider the support for the older versions to be deprecated in favor of pushing support for the final draft. The protocol versions supported at the time of writing are: 6, 7, 8, and 13 (13 being the protocol version of the final draft). We do not support 00/-76, so this may cause an issue with clients such as Safari which are still using this old version of the protocol.</p> 
 <p>Like other protocols implemented with Grizzly 2.x, WebSocket support is implemented using a Filter. If you’re not familiar with the concepts of Filters and FilterChains, please review the documentation in this guide.</p> 
</div> 
<div class="section"> 
 <h2 id="The_Grizzly_WebSocket_API">The Grizzly WebSocket API</h2> 
 <p>Understanding how to use the WebSocket API is very simple as there are only a few core entities that developers need to be familiar with. We’ll begin by covering those first. Once the basics are understood, creating websocket applications should be straight forward.</p> 
 <div class="section"> 
  <h3 id="WebSocket">WebSocket</h3> 
  <p>This interface provides the core functionality needed by developers to both send data to a remote end-point or handle events triggered by the remote end-point sending data. This interface is relevant for both server and client side uses cases.</p> 
  <div class="source"> 
   <pre>public interface WebSocket {


    /**
     * &lt;p&gt;
     * Send a text frame to the remote end-point.
     * &lt;p&gt;
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; send(String data);

    /**
     * &lt;p&gt;
     * Send a binary frame to the remote end-point.
     * &lt;/p&gt;
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; send(byte[] data);

    /**
     * &lt;p&gt;
     * Broadcasts the data to the remote end-point set.
     * &lt;/p&gt;
     *
     * @param recipients
     * @param data
     */
    void broadcast(final Iterable&lt;? extends WebSocket&gt; recipients, String data);

    /**
     * &lt;p&gt;
     * Broadcasts the data to the remote end-point set.
     * &lt;/p&gt;
     *
     * @param recipients
     * @param data
     */
    void broadcast(final Iterable&lt;? extends WebSocket&gt; recipients, byte[] data);

    /**
     * &lt;p&gt;
     * Broadcasts the data fragment to the remote end-point set.
     * &lt;/p&gt;
     *
     * @param recipients
     * @param data
     */
    void broadcastFragment(final Iterable&lt;? extends WebSocket&gt; recipients,
            String data, boolean last);

    /**
     * &lt;p&gt;
     * Broadcasts the data fragment to the remote end-point set.
     * &lt;/p&gt;
     *
     * @param recipients
     * @param data
     */
    void broadcastFragment(final Iterable&lt;? extends WebSocket&gt; recipients,
            byte[] data, boolean last);

    /**
     * Sends a &lt;code&gt;ping&lt;/code&gt; frame with the specified payload (if any).
     * &lt;/p&gt;
     *
     * @param data optional payload.  Note that payload length is restricted
     *  to 125 bytes or less.
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     *
     * @since 2.1.9
     */
    GrizzlyFuture&lt;DataFrame&gt; sendPing(byte[] data);

    /**
     * &lt;p&gt;
     * Sends a &lt;code&gt;ping&lt;/code&gt; frame with the specified payload (if any).
     * &lt;/p&gt;
     *
     * &lt;p&gt;It may seem odd to send a pong frame, however, RFC-6455 states:&lt;/p&gt;
     *
     * &lt;p&gt;
     *     &quot;A Pong frame MAY be sent unsolicited.  This serves as a
     *     unidirectional heartbeat.  A response to an unsolicited Pong frame is
     *     not expected.&quot;
     * &lt;/p&gt;
     *
     * @param data optional payload.  Note that payload length is restricted
     *  to 125 bytes or less.
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     *
     * @since 2.1.9
     */
    GrizzlyFuture&lt;DataFrame&gt; sendPong(byte[] data);

    /**
     * &lt;p&gt;
     * Sends a fragment of a complete message.
     * &lt;/p&gt;
     *
     * @param last boolean indicating if this message fragment is the last.
     * @param fragment the textual fragment to send.
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; stream(boolean last, String fragment);

    /**
     * &lt;p&gt;
     * Sends a fragment of a complete message.
     * &lt;/p&gt;
     *
     * @param last boolean indicating if this message fragment is the last.
     * @param fragment the binary fragment to send.
     * @param off the offset within the fragment to send.
     * @param len the number of bytes of the fragment to send.
     *
     * @return {@link GrizzlyFuture} which could be used to control/check the sending completion state.
     */
    GrizzlyFuture&lt;DataFrame&gt; stream(boolean last, byte[] fragment, int off, int len);

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket}.
     * &lt;/p&gt;
     */
    void close();

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket} using the specified status code.
     * &lt;/p&gt;
     *
     * @param code the closing status code.
     */
    void close(int code);

    /**
     * &lt;p&gt;
     * Closes this {@link WebSocket} using the specified status code and
     * reason.
     * &lt;/p&gt;
     *
     * @param code the closing status code.
     * @param reason the reason, if any.
     */
    void close(int code, String reason);

    /**
     * &lt;p&gt;
     * Convenience method to determine if this {@link WebSocket} is connected.
     * &lt;/p&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the {@link WebSocket} is connected, otherwise
     *  &lt;code&gt;false&lt;/code&gt;
     */
    boolean isConnected();

    /**
     * &lt;p&gt;
     * This callback will be invoked when the opening handshake between both
     * endpoints has been completed.
     * &lt;/p&gt;
     */
    void onConnect();

    /**
     * &lt;p&gt;
     * This callback will be invoked when a text message has been received.
     * &lt;/p&gt;
     *
     * @param text the text received from the remote end-point.
     */
    void onMessage(String text);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a binary message has been received.
     * &lt;/p&gt;
     *
     * @param data the binary data received from the remote end-point.
     */
    void onMessage(byte[] data);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a fragmented textual message has
     * been received.
     * &lt;/p&gt;
     *
     * @param last flag indicating whether or not the payload received is the
     *  final fragment of a message.
     * @param payload the text received from the remote end-point.
     */
    void onFragment(boolean last, String payload);

    /**
     * &lt;p&gt;
     * This callback will be invoked when a fragmented binary message has
     * been received.
     * &lt;/p&gt;
     *
     * @param last flag indicating whether or not the payload received is the
     *  final fragment of a message.
     * @param payload the binary data received from the remote end-point.
     */
    void onFragment(boolean last, byte[] payload);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point sent a closing
     * frame.
     * &lt;/p&gt;
     *
     * @param frame the close frame from the remote end-point.
     *
     * @see DataFrame
     */
    void onClose(DataFrame frame);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point has sent a ping
     * frame.
     * &lt;/p&gt;
     *
     * @param frame the ping frame from the remote end-point.
     *
     * @see DataFrame
     */
    void onPing(DataFrame frame);

    /**
     * &lt;p&gt;
     * This callback will be invoked when the remote end-point has sent a pong
     * frame.
     * &lt;/p&gt;
     *
     * @param frame the pong frame from the remote end-point.
     *
     * @see DataFrame
     */
    void onPong(DataFrame frame);

    /**
     * Adds a {@link WebSocketListener} to be notified of events of interest.
     *
     * @param listener the {@link WebSocketListener} to add.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the listener was added, otherwise
     *  &lt;code&gt;false&lt;/code&gt;
     *
     * @see WebSocketListener
     */
    boolean add(WebSocketListener listener);

    /**
     * Removes the specified {@link WebSocketListener} as a target of event
     * notification.
     *
     * @param listener the {@link WebSocketListener} to remote.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the listener was removed, otherwise
     *  &lt;code&gt;false&lt;/code&gt;
     *
     * @see WebSocketListener
     */
    boolean remove(WebSocketListener listener);

}
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="Broadcaster">Broadcaster</h3> 
  <p>New in 2.3 is the concept of the <i>Broadcaster</i>. In previous versions of Grizzly’s WebSocket implementation, when sending data, each call would result in a new frame instance being created. This operation is expensive - particularly when sending such data to thousands of sockets. An optimized Broadcaster implementation would frame the data once, and then send the framed result to each client. The WebSocket interface mirrors the methods defined here in Broadcaster and the defautl implementation of the WebSocket interface merely delegates the call to the Broadcaster implementation.</p> 
  <p>Here’s what the Broadcaster API looks like:</p> 
  <div class="source"> 
   <pre>/**
 * Broadcasts the provided &lt;tt&gt;text&lt;/tt&gt; content to the specified recipients.
 *
 * @param recipients the recipients of the provided &lt;tt&gt;text&lt;/tt&gt; content.
 * @param text       textual content.
 */
public void broadcast(final Iterable&lt;? extends WebSocket&gt; recipients,
                      final String text);

/**
 * Broadcasts the provided &lt;tt&gt;binary&lt;/tt&gt; content to the specified recipients.
 *
 * @param recipients the recipients of the provided &lt;tt&gt;binary&lt;/tt&gt; content.
 * @param binary     binary content.
 */
public void broadcast(final Iterable&lt;? extends WebSocket&gt; recipients,
                      final byte[] binary);

/**
 * Broadcasts the provided fragmented &lt;tt&gt;text&lt;/tt&gt; content to the specified recipients.
 *
 * @param recipients the recipients of the provided fragmented &lt;tt&gt;text&lt;/tt&gt; content.
 * @param text       fragmented textual content.
 * @param last       &lt;tt&gt;true&lt;/tt&gt; if this is the last fragment, otherwise &lt;tt&gt;false&lt;/tt&gt;.
 */
public void broadcastFragment(final Iterable&lt;? extends WebSocket&gt; recipients,
                              final String text,
                              final boolean last);

/**
 * Broadcasts the provided fragmented &lt;tt&gt;binary&lt;/tt&gt; content to the specified recipients.
 *
 * @param recipients the recipients of the provided fragmented &lt;tt&gt;binary&lt;/tt&gt; content.
 * @param binary     fragmented binary content.
 * @param last       &lt;tt&gt;true&lt;/tt&gt; if this is the last fragment, otherwise &lt;tt&gt;false&lt;/tt&gt;.
 */
public void broadcastFragment(final Iterable&lt;? extends WebSocket&gt; recipients,
                              final byte[] binary,
                              final boolean last);
</pre> 
  </div> 
  <p>As can be seen from the listing above, it is possible to send complete or fragmented messages in an optimized fashion. It should be noted that, by default, Grizzly will use an unoptimized version of the Broadcaster (to maintain behavioral compatibility with previous releases). In order to leverage the optimized version, see the following example:</p> 
  <div class="source"> 
   <pre>public static class BroadcastApplication extends WebSocketApplication {
    private final Broadcaster broadcaster;

    public BroadcastApplication(Broadcaster broadcaster) {
        this.broadcaster = broadcaster;
    }


    @Override
    public WebSocket createSocket(ProtocolHandler handler,
                                  HttpRequestPacket requestPacket,
                                  WebSocketListener... listeners) {
        final DefaultWebSocket ws =
                (DefaultWebSocket) super.createSocket(handler,
                requestPacket, listeners);

        ws.setBroadcaster(broadcaster);
        return ws;
    }

    @Override
    public void onMessage(WebSocket socket, String data) {
        socket.broadcast(getWebSockets(), data);
    }
}
</pre> 
  </div> 
  <p>The example is fairly straight forward. A custom Broadcaster implementation is provided to the constructor of the WebSocketApplication instance. When a new socket is created, this custom Broadcaster will provided and used by the various WebSocket broadcast calls. Given this example, one can simply do:</p> 
  <div class="source"> 
   <pre>WebSocketApplication app = new BroadcastApplication(new OptimizedBroadcaster());
</pre> 
  </div> 
  <p>NOTE: org.glassfish.grizzly.websockets.OptimizedBroadcaster is included with the distribution.</p> 
 </div> 
 <div class="section"> 
  <h3 id="WebSocketListener">WebSocketListener</h3> 
  <p>Implementations of this interface allow the developers to listen for events occurring on various WebSocket instances. This interface is relevant for both server and client side uses cases.</p> 
  <div class="source"> 
   <pre>/**
 * Interface to allow notification of events occurring on specific
 * {@link WebSocket} instances.
 */
public interface WebSocketListener {

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onClose(DataFrame)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;p&gt;
     *
     * @param socket the {@link WebSocket} being closed.
     * @param frame the closing {@link DataFrame} sent by the remote end-point.
     */
    void onClose(WebSocket socket, DataFrame frame);

    /**
     * &lt;p&gt;
     * Invoked when the opening handshake has been completed for a specific
     * {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the newly connected {@link WebSocket}
     */
    void onConnect(WebSocket socket);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onMessage(String)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received a message.
     * @param text the message received.
     */
    void onMessage(WebSocket socket, String text);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onMessage(String)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received a message.
     * @param bytes the message received.
     */
    void onMessage(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onPing(DataFrame)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received the ping.
     * @param bytes the payload of the ping frame, if any.
     */
    void onPing(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onPong(DataFrame)} has been called on a
     * particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} that received the pong.
     * @param bytes  the payload of the pong frame, if any.
     */
    void onPong(WebSocket socket, byte[] bytes);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onFragment(boolean, String)} has been called
     * on a particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket the {@link WebSocket} received the message fragment.
     * @param fragment the message fragment.
     * @param last flag indicating if this was the last fragment.
     */
    void onFragment(WebSocket socket, String fragment, boolean last);

    /**
     * &lt;p&gt;
     * Invoked when {@link WebSocket#onFragment(boolean, byte[])} has been called
     * on a particular {@link WebSocket} instance.
     * &lt;/p&gt;
     *
     * @param socket   the {@link WebSocket} received the message fragment.
     * @param fragment the message fragment.
     * @param last     flag indicating if this was the last fragment.
     */
    void onFragment(WebSocket socket, byte[] fragment, boolean last);

}
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="WebSocketApplication">WebSocketApplication</h3> 
  <p>The WebSocketApplication abstract class provides the basics for creating a server-side WebSocket application.</p> 
  <div class="source"> 
   <pre>**
 * Factory method to create new {@link WebSocket} instances.  Developers may
 * wish to override this to return customized {@link WebSocket} implementations.
 *
 * @param handler the {@link ProtocolHandler} to use with the newly created
 *  {@link WebSocket}.
 *
 * @param listeners the {@link WebSocketListener}s to associate with the new
 *   {@link WebSocket}.
 *
 * @return a new {@link WebSocket} instance.
 */
public WebSocket createSocket(ProtocolHandler handler, WebSocketListener... listeners) {
    ...
}

/**
 * When a {@link WebSocket#onClose(DataFrame)} is invoked, the {@link WebSocket}
 * will be unassociated with this application and closed.
 *
 * @param socket the {@link WebSocket} being closed.
 * @param frame the closing frame.
 */
@Override
public void onClose(WebSocket socket, DataFrame frame) {
    ...
}

/**
 * When a new {@link WebSocket} connection is made to this application, the
 * {@link WebSocket} will be associated with this application.
 *
 * @param socket the new {@link WebSocket} connection.
 */
@Override
public void onConnect(WebSocket socket) {
    ...
}

/**
 * Checks protocol specific information can and should be upgraded.
 *
 * The default implementation will check for the presence of the
 * &lt;code&gt;Upgrade&lt;/code&gt; header with a value of &lt;code&gt;WebSocket&lt;/code&gt;.
 * If present, {@link #isApplicationRequest(org.glassfish.grizzly.http.HttpRequestPacket)}
 * will be invoked to determine if the request is a valid websocket request.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the request should be upgraded to a
 *  WebSocket connection
 */
public final boolean upgrade(HttpRequestPacket request) {
    ...
}

/**
 * Checks application specific criteria to determine if this application can
 * process the request as a WebSocket connection.
 *
 * @param request the incoming HTTP request.
 * @return &lt;code&gt;true&lt;/code&gt; if this application can service this request
 *         &lt;p/&gt;
 * @deprecated URI mapping shouldn't be intrinsic to the application.
 *  WebSocketApplications should be registered using {@link WebSocketEngine#register(String, String, WebSocketApplication)}
 *  using standard Servlet url-pattern rules.
 */
public boolean isApplicationRequest(HttpRequestPacket request) {
    return false;
}
</pre> 
  </div> 
  <p>So to create a simple server-side WebSocket application, the developer, at a minimum, would extend this class. It’s no longer required nor recommended to override isApplicationRequest(). Applications should be registered with the WebSocketEngine with a url pattern. Additional functionality can be added as required for the application - keep in mind that the WebSocketApplication is, itself, a WebSocketListener which will be added to each WebSocket registered with it. This allows handling all of the events exposed by WebSocketListener (as previously discussed). A word of caution - if overriding WebSocketApplication{onConnect,onClosed} be sure to make a call to the super() so that the WebSocket is properly associated/unassociated with the application to prevent leaks.</p> 
 </div> 
 <div class="section"> 
  <h3 id="WebSocketEngine">WebSocketEngine</h3> 
  <p>The final piece of the API developers should understand is the WebSocketEngine. The WebSocketEngine is a JVM singleton in which all WebSocketApplications are registered. The methods of interest here are register/unregister:</p> 
  <div class="source"> 
   <pre>/**
 * Register a WebSocketApplication to a specific context path and url pattern.
 * If you wish to associate this application with the root context, use an
 * empty string for the contextPath argument.
 *
 * &lt;pre&gt;
 * Examples:
 *   // WS application will be invoked:
 *   //    ws://localhost:8080/echo
 *   // WS application will not be invoked:
 *   //    ws://localhost:8080/foo/echo
 *   //    ws://localhost:8080/echo/some/path
 *   register(&quot;&quot;, &quot;/echo&quot;, webSocketApplication);
 *
 *   // WS application will be invoked:
 *   //    ws://localhost:8080/echo
 *   //    ws://localhost:8080/echo/some/path
 *   // WS application will not be invoked:
 *   //    ws://localhost:8080/foo/echo
 *   register(&quot;&quot;, &quot;/echo/*&quot;, webSocketApplication);
 *
 *   // WS application will be invoked:
 *   //    ws://localhost:8080/context/echo
 *
 *   // WS application will not be invoked:
 *   //    ws://localhost:8080/echo
 *   //    ws://localhost:8080/context/some/path
 *   register(&quot;/context&quot;, &quot;/echo&quot;, webSocketApplication);
 * &lt;/pre&gt;
 *
 * @param contextPath the context path (per servlet rules)
 * @param urlPattern url pattern (per servlet rules)
 * @param app the WebSocket application.
 */
public synchronized void register(String contextPath, String urlPattern, WebSocketApplication app) {
    ...
}

/**
 *
 * @deprecated Use {@link #register(String, String, WebSocketApplication)}
 */
@Deprecated
public synchronized void register(WebSocketApplication app) {
    ...
}

/**
 * Un-registers the specified {@link WebSocketApplication} with the
 * &lt;code&gt;WebSocketEngine&lt;/code&gt;.
 *
 * @param app the {@link WebSocketApplication} to un-register.
 */
public void unregister(WebSocketApplication app) {
    ...
}

/**
 * Un-registers all {@link WebSocketApplication} instances with the
 * {@link WebSocketEngine}.
 */
public void unregisterAll() {
    ...
}
</pre> 
  </div> 
  <p>Registration may occur at any time. For example, if this application is created/registered by a Servlet, then registration would happen in the Servlet.init() method and de-registration may happen within the Servlet.destroy() method. Regardless, the WebSocketApplication must be registered with the WebSocketEngine in order to be queried as part of the connection upgrade process.</p> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Using_Grizzly_2_WebSockets_on_the_Server-Side">Using Grizzly 2 WebSockets on the Server-Side</h2> 
 <p>In the previous sections we touched briefly how the WebSocket protocol is implemented and the basic API. We’ll now show the basics for creating a WebSocket aware server and registering the WebSocketApplication with the WebSocket runtime.</p> 
 <p>In this example, we’ll be using Grizzly standalone (of course!). So first, we’ll create the HttpServer and enable WebSocket support.</p> 
 <div class="source"> 
  <pre>final HttpServer server = HttpServer.createSimpleServer(&quot;/var/www&quot;, 8080);
final WebSocketAddOn addon = new WebSocketAddOn();
for (NetworkListener listener : server.getListeners()) {
    listener.registerAddOn(addon);
}
</pre> 
 </div> 
 <p>That’s all there is to it! Note, that you don’t need to register the addon for all listeners, only those listeners that you want WebSocket support.</p> 
 <p>Next, we instantiate a WebSocketApplication implementation (we don’t go into the details of the implementation itself - that comes later) and register it with the WebSocket runtime.</p> 
 <div class="source"> 
  <pre>final WebSocketApplication chatApplication = new ChatApplication();
WebSocketEngine.getEngine().register(chatApplication, &quot;/chat&quot;);
</pre> 
 </div> 
 <p>Again, simple! Once the server is started, it will be ready to service WebSocket requests.</p> 
 <p>For a more concrete (and runnable) example, review this simple <a class="externalLink" href="https://github.com/javaee/grizzly/tree/8e9924aa5a33a30bedc17fbfb3f7714b3946a6a7/samples/websockets/chat">WebSocket Chat</a> application.</p> 
</div> 
<div class="section"> 
 <h2 id="Grizzly_WebSockets_Client">Grizzly WebSockets Client</h2> 
 <p>The Grizzly project does have a WebSocket client if such functionality is needed. Instead of repeating what has already been written, we’ll recommend that you read the following <a class="externalLink" href="https://web.archive.org/web/20180322054558/http://www.notshabby.net:80/2012/01/async-http-client-1-7-0-released-details-on-the-grizzly-side-of-things">blog entry</a> (courtesy the Wayback machine).</p> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->

	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Main</li>
						<li >
							<a href="index.html" title="Home">Home</a>
						</li>
						<li >
							<a href="license.html" title="License">License</a>
						</li>
						<li >
							<a href="using.html" title="Who's Using Grizzly">Who's Using Grizzly</a>
						</li>
						<li class="nav-header">Download</li>
						<li >
							<a href="dependencies.html" title="Download">Download</a>
						</li>
					</ul>
				</div>
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Contribute</li>
						<li >
							<a href="contribute.html" title="Contribute">Contribute</a>
						</li>
						<li >
							<a href="http://stackoverflow.com/questions/tagged/grizzly" title="StackOverflow" class="externalLink">StackOverflow</a>
						</li>
						<li >
							<a href="mailing.html" title="Mailing Lists">Mailing Lists</a>
						</li>
					</ul>
				</div>
				<div class="span4 bottom-nav">
					<ul class="nav nav-list">
					</ul>
				</div>
				<div class="span0 bottom-description">
					<blockquote><div id="archive-footer" style="left: 0px;">This project is now part of the <a href="https://projects.eclipse.org/projects/ee4j">Jakarta EE Working Group</a> and has been transferred to the Eclipse Foundation.<br/>Please visit <a href="https://projects.eclipse.org/projects/ee4j.grizzly">Eclipse Grizzly</a> for all the latest developments (or the new <a href="https://github.com/eclipse-ee4j/grizzly">GitHub Repo</a>).
		</div>
						<p>
                        <a href="http://www.jetbrains.com/idea/" style="position: relative;display:block; width:120px; height:30px; border:0; margin:0;padding:0;text-decoration:none;text-indent:0;"><span style="margin: 0;padding: 0;position: absolute;top: -1px;left: 29px;font-size: 9px;cursor:pointer;  background-image:none;border:0;color: #acc4f9; font-family: trebuchet ms,arial,sans-serif;font-weight: normal;text-align:left;"></span><img src="images/logo-text.png" alt="The best Java IDE" border="0"/></a>
                        </p></blockquote>
				</div>
			</div>
		</div>
	</footer>

	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2013-2021. All Rights Reserved.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

	<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/lightbox.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/reflow-scroll.js"></script>
	<script src="//yandex.st/highlightjs/7.5/highlight.min.js"></script>

	<script src="https://javaee.github.io/grizzly//js/reflow-skin.js"></script>

	</body>
</html>
