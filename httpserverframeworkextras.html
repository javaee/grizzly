
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2017-05-04
 Rendered using Maven Reflow Skin 1.0.0 (http://andriusvelykis.github.com/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>Project Grizzly - Http Server Framework Extras</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />
 
		<link href="//netdna.bootstrapcdn.com/bootswatch/2.2.2/cosmo/bootstrap.min.css" rel="stylesheet" />
		<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/bootswatch.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/reflow-skin.css" rel="stylesheet" />
		
		<link href="//yandex.st/highlightjs/7.3/styles/solarized_dark.min.css" rel="stylesheet" />
		
		<link href="https://javaee.github.io/grizzly//css/lightbox.css" rel="stylesheet" />
		
		<link href="https://javaee.github.io/grizzly//css/site.css" rel="stylesheet" />
		<link href="https://javaee.github.io/grizzly//css/print.css" rel="stylesheet" media="print" />
		
		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->

	</head>

	<body class="page-httpserverframeworkextras project-site" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html">Project <span class="color-brown">Grizzly</span></a>
					<div class="nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li><a href="dependencies.html" title="Download">Download </a></li>
								</ul>
							</li>
							<li class="dropdown active">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li><a href="overview.html" title="Overview">Overview </a></li>
									<li><a href="dependencies.html" title="Dependencies">Dependencies </a></li>
									<li class="dropdown-submenu">
										<a href="hack" title="Core Framework">Core Framework </a>
										<ul class="dropdown-menu">
											<li><a href="memory.html" title="Memory Management">Memory Management </a></li>
											<li><a href="iostrategies.html" title="I/O Strategies">I/O Strategies </a></li>
											<li><a href="transportsconnections.html" title="Transports and Connections">Transports and Connections </a></li>
											<li><a href="filterchainfilters.html" title="FilterChain and Filters">FilterChain and Filters </a></li>
											<li><a href="coreconfig.html" title="Core configuration">Core configuration </a></li>
											<li><a href="portunification.html" title="Port Unification">Port Unification </a></li>
											<li><a href="monitoring.html" title="Monitoring">Monitoring </a></li>
											<li><a href="extras.html" title="Extras">Extras </a></li>
											<li><a href="bestpractices.html" title="Best Practices">Best Practices </a></li>
											<li><a href="quickstart.html" title="Quick Start">Quick Start </a></li>
											<li><a href="samples.html" title="Samples">Samples </a></li>
										</ul>
									</li>
									<li class="dropdown-submenu">
										<a href="hack" title="HTTP">HTTP </a>
										<ul class="dropdown-menu">
											<li><a href="httpframework.html" title="Core HTTP Framework">Core HTTP Framework </a></li>
											<li><a href="httpserverframework.html" title="HTTP Server Framework">HTTP Server Framework </a></li>
											<li><a href="http2.html" title="HTTP/2">HTTP/2 </a></li>
											<li class="active"><a href="" title="HTTP Server Framework Extras">HTTP Server Framework Extras </a></li>
											<li><a href="comet.html" title="Comet">Comet </a></li>
											<li><a href="jaxws.html" title="JAXWS">JAXWS </a></li>
											<li><a href="websockets.html" title="WebSockets">WebSockets </a></li>
											<li><a href="ajp.html" title="AJP">AJP </a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>
		
	<div class="container">
	
	<!-- Masthead
	================================================== -->
	<header class="jumbotron subhead">
		<div class="row" id="banner">
			<div class="span12">
				<div class="pull-left">
					<a href="index.html" id="bannerLeft"><h1><img src="images/grizzlyHead.png"/>&nbsp;<span class="color-black">Project</span> Grizzly</h1></a>
					<p class="lead">NIO Event Development Simplified</p>
				</div>
				<div class="pull-right">
				</div>
			</div>
		</div>
		<div>
			<ul class="breadcrumb">
				<li class="publishDate version-date">Last Published: 2017-05-04</li>
			</ul>
		</div>
		<hr class="toc-separator" />
		<div id="toc-bar" class="navbar">
			<div class="navbar-inner">
				<div id="toc-scroll-target" class="container">
					<ul id="toc" class="nav">
						<li class="toplevel"><a href="#Http_Server_Framework_Extras" title="Http Server Framework Extras">Http Server Framework Extras</a></li>
						<li class="divider-vertical"></li>
						<li class="toplevel"><a href="#Multipart_multipartform-data_HTTP_Requests_Processing" title="Multipart (multipart/form-data) HTTP Requests Processing">Multipart (multipart/form-data) HTTP Requests Processing</a></li>
						<li class="toplevel"><a href="#Dependencies" title="Dependencies">Dependencies</a></li>
						<li class="toplevel"><a href="#Sample" title="Sample">Sample</a></li>
					</ul>
				</div>
			</div>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="section"> 
 <div class="page-header">
  <h2 id="Http_Server_Framework_Extras">Http Server Framework Extras</h2>
 </div> 
 <p>The extra Grizzly HTTP server framework features, provided by separate modules</p> 
</div> 
<div class="section"> 
 <h2 id="Multipart_multipartform-data_HTTP_Requests_Processing">Multipart (multipart/form-data) HTTP Requests Processing</h2> 
 <p>File sharing has become a very popular internet service where users are able to upload files and share them for group of people. Typically users will upload their files via a regular HTML form like:</p> 
 <div class="source"> 
  <pre>&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;
  &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;
&lt;/form&gt;
</pre> 
 </div> 
 <p>where after you press “submit”, a multipart HTTP request is generated. For the example above, the HTTP request will contain two parts: text description and chosen file content, like:</p> 
 <div class="source"> 
  <pre>POST /upload HTTP/1.1
Host: localhost:18080
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.7,uk;q=0.3
Content-Type: multipart/form-data; boundary=---------------------------78965753017082023611608934090
Content-Length: 357

-----------------------------78965753017082023611608934090
Content-Disposition: form-data; name=&quot;description&quot;

some text file
-----------------------------78965753017082023611608934090
Content-Disposition: form-data; name=&quot;fileName&quot;; filename=&quot;test.txt&quot;
Content-Type: text/plain

TEST
-----------------------------78965753017082023611608934090--
</pre> 
 </div> 
 <p>When using the Grizzly http-server module, the content of the message above will be represented as one single message together with boundaries. This means the user will be responsible for parsing content himself or use an existing library (which, most likely, will process processes multipart requests in a blocking fashion).</p> 
 <p>The Grizzly http-server-multipart module provides an API which simplifies multipart HTTP requests processing and does so in a non-blocking fashion. At the core of the API is the MultipartScanner, containing two “scan” methods:</p> 
 <ul> 
  <li>Top level multipart HTTP request scanner (multipart/form-data)</li> 
 </ul> 
 <div class="source"> 
  <pre>public static void scan(final Request request,
        final MultipartEntryHandler partHandler,
        final CompletionHandler&lt;Request&gt; completionHandler);
</pre> 
 </div> 
 <ul> 
  <li>multipart/mixed entries scanner</li> 
 </ul> 
 <div class="source"> 
  <pre>public static void scan(final MultipartEntry multipartMixedEntry,
        final MultipartEntryHandler partHandler,
        final CompletionHandler&lt;MultipartEntry&gt; completionHandler);
</pre> 
 </div> 
 <p>By calling one of the methods above, we initialize asynchronous multipart request processing which is going to be handled by the provided MultipartEntryHandler (which is very similar to HttpHandler) and ultimately passed CompletionHandler will be notified about multipart HTTP request processing (i.e., success or error).</p> 
 <p>The MultipartEntryHandler API is very simple and looks very similar to HttpHandler:</p> 
 <div class="source"> 
  <pre>/**
 * General interface for processing {@link MultipartEntry}s, one by one.
 *
 * @since 2.1
 */
public interface MultipartEntryHandler {
    /**
     * The method is called once {@link MultipartEntry} header is ready to be
     * processed by user code.
     *
     * @param part {@link MultipartEntry}
     * @throws Exception
     */
    public void handle(final MultipartEntry multipartEntry) throws Exception;
}
</pre> 
 </div> 
 <p>Inside the handle(…) method we’re able to process the passed multipart entry, check its content type, disposition etc., and finally initialize the asynchronous non-blocking processing of an entry’s content using either the NIOInputStream (binary mode) or the NIOReader (text mode) API described in the http-server <a href="httpserverframework.html">documentation</a>:</p> 
 <div class="source"> 
  <pre>NIOInputStream nioInputStream = multipartEntry.getNIOInputStream();
</pre> 
 </div> 
 <p>or</p> 
 <div class="source"> 
  <pre>NIOReader nioReader = multipartEntry.getNIOReader();
</pre> 
 </div> 
 <p>Please note, unlike the NIOInputStream and NIOReader got from HTTP Request, the implementations provided by MultipartEntry expose the content of a single multipart entry and report end of stream once end of multipart entry is reached.</p> 
 <p>Also it’s important to understand that multipart message processing is asynchronous, so we have to suspend HTTP request processing before starting the scan. Also, don’t forget to resume the HTTP request processing inside the passed CompletionHandler. See http-server <a href="httpserverframework.html">documentation</a> for more information on HTTP request suspend/resume.</p> 
 <div class="section"> 
  <h3 id="Dependencies">Dependencies</h3> 
  <p>Maven developers require a dependency on the http-server-multipart module. The following dependency needs to be added to the pom:</p> 
  <div class="source"> 
   <pre>&lt;dependency&gt;
     &lt;groupId&gt;org.glassfish.grizzly&lt;/groupId&gt;
     &lt;artifactId&gt;grizzly-http-server-multipart&lt;/artifactId&gt;
     &lt;version&gt;@VERSION@&lt;/version&gt;
&lt;/dependency&gt;
</pre> 
  </div> 
  <p>Non-maven developers: additional dependencies: <a href="#http-server-dep">HTTP Server framework</a>, required by:</p> 
  <ul> 
   <li><a class="externalLink" href="https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/grizzly-http-servlet/@VERSION@/grizzly-http-server-multipart-@VERSION@.jar">grizzly-http-server-multipart.jar</a></li> 
  </ul> 
 </div> 
 <div class="section"> 
  <h3 id="Sample">Sample</h3> 
  <p>Let’s see how a file-uploader implementation may be implemented.</p> 
  <p>First of all let’s create HttpHandler, which would be responsible for multipart HTTP requests processing:</p> 
  <div class="source"> 
   <pre>public class UploaderHttpHandler extends HttpHandler {
    private static final String DESCRIPTION_NAME = &quot;description&quot;;
    private static final String FILENAME_ENTRY = &quot;fileName&quot;;

    // uploads counter (just for debugging/tracking reasons)
    private final AtomicInteger uploadsCounter = new AtomicInteger(1);

    /**
     * Service HTTP request.
     */
    @Override
    public void service(final Request request, final Response response)
            throws Exception {

        // Suspend the HTTP request processing
        // (in other words switch to asynchronous HTTP processing mode).
        response.suspend();

        // assign uploadNumber for this specific upload
        final int uploadNumber = uploadsCounter.getAndIncrement();

        // Initialize MultipartEntryHandler, responsible for handling
        // multipart entries of this request
        final UploaderMultipartHandler uploader =
                new UploaderMultipartHandler(uploadNumber);

        // Start the asynchronous multipart request scanning...
        MultipartScanner.scan(request,
                uploader,
                new EmptyCompletionHandler&lt;Request&gt;() {
            // CompletionHandler is called once HTTP request processing is completed
            // or failed.
            @Override
            public void completed(final Request request) {
                // Upload is complete
                final int bytesUploaded = uploader.getBytesUploaded();

                // Compose a server response.
                try {
                    response.setContentType(&quot;text/plain&quot;);
                    final Writer writer = response.getWriter();
                    writer.write(&quot;Completed. &quot; + bytesUploaded + &quot; bytes uploaded.&quot;);
                } catch (IOException ignored) {
                }

                // Resume the asynchronous HTTP request processing
                // (in other words finish the asynchronous HTTP request processing).
                response.resume();
            }

            @Override
            public void failed(Throwable throwable) {
                // Complete the asynchronous HTTP request processing.
                response.resume();
            }
        });
    }
}
</pre> 
  </div> 
  <p>The important part in the code is calls to response.suspend() before starting the multipart request scanning and response.resume() once multipart HTTP request is processed.</p> 
  <p>Now we’re ready to take a look at the UploaderMultipartHandler code, which is responsible for processing single multipart entries:</p> 
  <div class="source"> 
   <pre>/**
 * {@link MultipartEntryHandler}, responsible for processing the upload.
 */
private final class UploaderMultipartHandler
        implements MultipartEntryHandler {

    // upload number
    private final int uploadNumber;
    // number of bytes uploaded
    private final AtomicInteger uploadedBytesCounter = new AtomicInteger();

    public UploaderMultipartHandler(final int uploadNumber) {
        this.uploadNumber = uploadNumber;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void handle(final MultipartEntry multipartEntry) throws Exception {
        // get the entry's Content-Disposition
        final ContentDisposition contentDisposition =
                multipartEntry.getContentDisposition();
        // get the multipart entry name
        final String name = contentDisposition.getDispositionParamUnquoted(&quot;name&quot;);

        // if the multipart entry contains a file content
        if (FILENAME_ENTRY.equals(name)) {

            // get the filename for Content-Disposition
            final String filename =
                    contentDisposition.getDispositionParamUnquoted(&quot;filename&quot;);

            // Get the NIOInputStream to read the multipart entry content
            final NIOInputStream inputStream = multipartEntry.getNIOInputStream();

            // start asynchronous non-blocking content read.
            inputStream.notifyAvailable(
                    new UploadReadHandler(uploadNumber, filename,
                    inputStream, uploadedBytesCounter));

        } else if (DESCRIPTION_NAME.equals(name)) { // if multipart entry contains a description field
            // skip the multipart entry
            multipartEntry.skip();
        } else { // Unexpected entry?
            // skip it
            multipartEntry.skip();
        }
    }

    /**
     * Returns the number of bytes uploaded for this multipart entry.
     *
     * @return the number of bytes uploaded for this multipart entry.
     */
    int getBytesUploaded() {
        return uploadedBytesCounter.get();
    }
}
</pre> 
  </div> 
  <p>Inside the handle(…) method we check if the multipart entry represents a file to be uploaded, because as we mentioned in the beginning, the HTTP multipart request contains two multipart entries: one for description and the second for actual file content. If the multipart entry represents a text description, we just skip it by calling multipartEntry.skip(). However, if multipart entry represents file content, we start the asynchronous content reading using NIOInputStream.</p> 
  <p>Let’s see how our asynchronous ReadHandler looks like:</p> 
  <div class="source"> 
   <pre>/**
 * Simple {@link ReadHandler} implementation, which is reading HTTP request
 * content (uploading file) in non-blocking mode and saves the content into
 * the specific file.
 */
private class UploadReadHandler implements ReadHandler {

    // the upload number
    private final int uploadNumber;
    // Non-blocking multipart entry input stream
    private final NIOInputStream inputStream;

    // the destination file output stream, where we save the data.
    private final FileOutputStream fileOutputStream;

    // temporary buffer
    private final byte[] buf;

    // uploaded bytes counter
    private final AtomicInteger uploadedBytesCounter;

    private UploadReadHandler(final int uploadNumber,
            final String filename,
            final NIOInputStream inputStream,
            final AtomicInteger uploadedBytesCounter)
            throws FileNotFoundException {

        this.uploadNumber = uploadNumber;
        fileOutputStream = new FileOutputStream(filename);
        this.inputStream = inputStream;
        this.uploadedBytesCounter = uploadedBytesCounter;
        buf = new byte[2048];
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void onDataAvailable() throws Exception {
        // save available file content
        readAndSaveAvail();

        // register this handler to be notified next time some data
        // becomes available
        inputStream.notifyAvailable(this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void onAllDataRead() throws Exception {
        // save available file content
        readAndSaveAvail();
        // finish the upload
        finish();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void onError(Throwable t) {
        // finish the upload
        finish();
    }

    /**
     * Read available file content data out of HTTP request and save the
     * chunk into local file output stream
     *
     * @throws IOException
     */
    private void readAndSaveAvail() throws IOException {
        while (inputStream.isReady()) {
            // read the available bytes from input stream
            final int readBytes = inputStream.read(buf);
            // update the counter
            uploadedBytesCounter.addAndGet(readBytes);
            // save the file content to the file
            fileOutputStream.write(buf, 0, readBytes);
        }
    }

    /**
     * Finish the file upload
     */
    private void finish() {
        try {
            // close file output stream
            fileOutputStream.close();
        } catch (IOException ignored) {
        }
    }
}
</pre> 
  </div> 
  <p>As you can see, the logic is pretty simple. Once the ReadHandler is notified about data being available, we read the data off the NIOInputStream and store it to a local file. If we expect more data, we just re-register the ReadHandler to wait for it to be notified. If there is no more data to be processed, finish the upload by closing the local file output stream.</p> 
  <p>The complete working sample could be downloaded <a class="externalLink" href="https://maven.java.net/content/repositories/releases/org/glassfish/grizzly/samples/grizzly-http-multipart-samples/@VERSION@/grizzly-http-multipart-samples-@VERSION@-sources.jar">here</a></p> 
 </div> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->
	
	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Main</li>
						<li>
							<a href="index.html" title="Home">Home </a>
						</li>
						<li>
							<a href="license.html" title="License">License </a>
						</li>
						<li>
							<a href="using.html" title="Who's Using Grizzly">Who's Using Grizzly </a>
						</li>
						<li class="nav-header">Download</li>
						<li>
							<a href="dependencies.html" title="Download">Download </a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Contribute</li>
						<li>
							<a href="contribute.html" title="Contribute">Contribute </a>
						</li>
						<li>
							<a href="http://stackoverflow.com/questions/tagged/grizzly" title="StackOverflow" class="externalLink">StackOverflow </a>
						</li>
						<li>
							<a href="https://twitter.com/project_grizzly" title="Twitter" class="externalLink">Twitter </a>
						</li>
						<li>
							<a href="mailing.html" title="Mailing Lists">Mailing Lists </a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Project Info</li>
						<li>
							<a href="./" title="Source Control">Source Control </a>
						</li>
						<li>
							<a href="issues" title="Issue Tracking">Issue Tracking </a>
						</li>
						<li>
							<a href="mailing.html" title="Mailing Lists">Mailing Lists </a>
						</li>
						<li>
							<a href="team-list.html" title="Project Team">Project Team </a>
						</li>
					</ul>
				</div>
			</div>
		</div>
	</footer>
		
	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2017. All Rights Reserved.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->

	<!-- Fallback jQuery loading from Google CDN:
	     http://stackoverflow.com/questions/1014203/best-way-to-use-googles-hosted-jquery-but-fall-back-to-my-hosted-library-on-go -->
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
	<script type="text/javascript">
		if (typeof jQuery == 'undefined')
		{
			document.write(unescape("%3Cscript src='https://javaee.github.io/grizzly//js/jquery-1.8.3.min.js' type='text/javascript'%3E%3C/script%3E"));
		}
	</script>
	
	<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
	<script src="https://javaee.github.io/grizzly//js/lightbox.js"></script>
	<script src="https://javaee.github.io/grizzly//js/jquery.smooth-scroll.min.js"></script>
	<!-- back button support for smooth scroll -->
	<script src="https://javaee.github.io/grizzly//js/jquery.ba-bbq.min.js"></script>
	<script src="//yandex.st/highlightjs/7.3/highlight.min.js"></script>

	<script src="https://javaee.github.io/grizzly//js/reflow-skin.js"></script>
	
	</body>
</html>
